# COPYRIGHT:
#
# This software is Copyright (c) 2010 - 2015 NETWAYS GmbH
#                                <support@netways.de>
#
# (Except where explicitly superseded by other copyright notices)
#
#
# LICENSE:
#
# This work is made available to you under the terms of Version 2 of
# the GNU General Public License. A copy of that license should have
# been provided with this software, but in any event can be snarfed
# from http://www.fsf.org.
#
# This work is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301 or visit their web page on the internet at
# http://www.fsf.org.
#
#
# CONTRIBUTION SUBMISSION POLICY:
#
# (The following paragraph is not intended to limit the rights granted
# to you to modify and distribute this software under the terms of
# the GNU General Public License and is only of importance to you if
# you choose to contribute your changes and enhancements to the
# community by submitting them to NETWAYS GmbH.)
#
# By intentionally submitting any modifications, corrections or
# derivatives to this work, or any other work intended for use with
# this Software, to NETWAYS GmbH, you confirm that
# you are the copyright holder for those contributions and you grant
# NETWAYS GmbH a nonexclusive, worldwide, irrevocable,
# royalty-free, perpetual, license to use, copy, create derivative
# works based on those contributions, and sublicense and distribute
# those contributions and any derivatives thereof.
#
# Nagios and the Nagios logo are registered trademarks of Ethan Galstad.

#
# TIMEPERIODS
#
sub genTimeperiods {
    my $CONFIG = shift;
    my $target = shift;
    my $dir    = shift;
    my $format = shift;
    my $outputDir;

    # set output dir
    if (defined $dir) { $outputDir = $dir; } else { $outputDir = $opt->{outputDir}; }

    # get all timeperiods
    my $TIMEPERIODS = HashGrep($CONFIG, 'objectclass', $cfg->{ldap}->{prefix}.'Timeperiod');

    # check all timeperiods... are they below $cfg->{ldap}->{baseDN} ?
    # --> so timeperiod objects in ou=Examples and ou=Templates will not be handled
    foreach my $val (keys %{$TIMEPERIODS}) { delete $TIMEPERIODS->{$val} if $val !~ /$cfg->{ldap}->{baseDN}$/; }

    # a special target is set?
    if (defined($target)) { foreach my $val (keys %{$TIMEPERIODS}) { delete $TIMEPERIODS->{$val} if $val !~ /$target$/; } }

    if (defined $cfg->{export}->{format} && $cfg->{export}->{format} == 2) {
        genTimeperiods2x($TIMEPERIODS, $outputDir);
    } else {
        genTimeperiods1x($TIMEPERIODS, $outputDir);
    }
}

sub genTimeperiods1x {
    my $TIMEPERIODS = shift;
    my $outputDir = shift;

    foreach my $timeperiod (keys %{$TIMEPERIODS}) {

        # get target file's name and open it for writing
        my $writeFile = BuildFilepath($TIMEPERIODS->{$timeperiod}->{dn}, $outputDir);
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

        print FH "define timeperiod {\n";
        foreach (sort keys %{$TIMEPERIODS->{$timeperiod}}) {
            if ($itemMap{$_} || $_ eq "$cfg->{ldap}->{prefix}timeperiodvalue") {
                if ($_ eq 'cn') {
                    print FH "\ttimeperiod_name\t$TIMEPERIODS->{$timeperiod}->{$_}\n";
                } elsif ($_ eq "$cfg->{ldap}->{prefix}timeperiodvalue") {
                    foreach my $val (sort keys %{$TIMEPERIODS->{$timeperiod}->{$_}}) {
                        foreach my $timeperiod_value (sort keys %{$TIMEPERIODS->{$timeperiod}->{$_}->{$val}}) {
                            my $key = $timeperiod_value;
                            $key =~ s/^\s+//;
                            $key =~ s/^\t//;
                            $key =~ s/\s+$//;
                            $key =~ s/\t$//;
                            print FH "\t$key\t$TIMEPERIODS->{$timeperiod}->{$_}->{$val}->{$timeperiod_value}\n";
                        }
                    }
                } else {
                    print FH "\t$itemMap{$_}\t$TIMEPERIODS->{$timeperiod}->{$_}\n";
                }
            }
        }
        print FH "}\n";

        # close target file
        close(FH);
    }
}

sub genTimeperiods2x {
    my $TIMEPERIODS = shift;
    my $outputDir = shift;

    foreach my $timeperiod (keys %{$TIMEPERIODS}) {

        # get target file's name and open it for writing
        my $writeFile = BuildFilepath($TIMEPERIODS->{$timeperiod}->{dn}, $outputDir);
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

        print FH "object TimePeriod \"$TIMEPERIODS->{$timeperiod}->{cn}\"{\n";
        print FH "\timport \"legacy-timeperiod\"\n";
        print FH "\tranges = {\n";
        foreach (sort keys %{$TIMEPERIODS->{$timeperiod}}) {
            if ($_ eq "$cfg->{ldap}->{prefix}timeperiodvalue") {
                foreach my $val (sort keys %{$TIMEPERIODS->{$timeperiod}->{$_}}) {
                    foreach my $timeperiod_value (sort keys %{$TIMEPERIODS->{$timeperiod}->{$_}->{$val}}) {
                        my $key = $timeperiod_value;
                        $key =~ s/^\s+//;
                        $key =~ s/^\t//;
                        $key =~ s/\s+$//;
                        $key =~ s/\t$//;
                        print FH "\t\t\"$key\" = \"$TIMEPERIODS->{$timeperiod}->{$_}->{$val}->{$timeperiod_value}\"\n";
                    }
                }
            }
        }
        print FH "\t}\n";
        print FH "}\n";

        # close target file
        close(FH);
    }
}

#
# COMMANDS
#
sub genCommands {
    my $CONFIG = shift;
    my $target = shift;
    my $dir    = shift;
    my $outputDir;

    # set output dir
    if (defined $dir) { $outputDir = $dir; } else { $outputDir = $opt->{outputDir}; }

    # get all commands
    my $COMMANDS = HashGrep($CONFIG, 'objectclass', $cfg->{ldap}->{prefix}.'Command');

    # check all commands... are they below $cfg->{ldap}->{baseDN} ?
    # --> so command objects in ou=Examples and ou=Templates will not be handled
    foreach my $val (keys %{$COMMANDS}) { delete $COMMANDS->{$val} if $val !~ /$cfg->{ldap}->{baseDN}$/; }

    # a special target is set?
    if (defined($target)) { foreach my $val (keys %{$COMMANDS}) { delete $COMMANDS->{$val} if $val !~ /$target$/; } }

    if (defined $cfg->{export}->{format} && $cfg->{export}->{format} == 2) {
        genCommands2x($COMMANDS, $outputDir, 'Check');
        # This is ugly but ensures that we'll have all contact notification commands available as NotificationCommand.
        # This duplicates all CheckCommands into NotificationCommands, but right now it is way less expensive than generating
        # one each time a host/service contact list is run through.
        genCommands2x($COMMANDS, $outputDir, 'Notification');
    } else {
        genCommands1x($COMMANDS, $outputDir);
    }
}

sub genCommands1x {
    my $COMMANDS = shift;
    my $outputDir = shift;

    foreach my $command (keys %{$COMMANDS}) {

        # get target file's name and open it for writing
        my $writeFile = BuildFilepath($COMMANDS->{$command}->{dn}, $outputDir);
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

        print FH "define command {\n";
        foreach (sort keys %{$COMMANDS->{$command}}) {
            if ($itemMap{$_}) {
                if ($_ eq 'cn') {
                    print FH "\tcommand_name\t $COMMANDS->{$command}->{$_}\n";
                } else {
                    print FH "\t$itemMap{$_}\t $COMMANDS->{$command}->{$_}\n";
                }
            }
        }
        print FH "}\n";

        # close target file
        close(FH);
    }
}

sub genCommands2x {
    my $COMMANDS = shift;
    my $outputDir = shift;
    my $type = shift; #FIXME for notifications/events

    foreach my $command (keys %{$COMMANDS}) {

        # get target file's name and open it for writing
        my $tmpPath = BuildFilepath($COMMANDS->{$command}->{dn}, $outputDir);
        $tmpPath =~ s/\.conf//g;
        my $writeFile = $tmpPath."_".lc($type).".conf"; # ugly hack to dump all types within their own file

        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

        print FH "object ".$type."Command \"$COMMANDS->{$command}->{cn}\" {\n";
        print FH "\timport \"generic-".lc(type)."-command\"\n";
        foreach (keys %{$COMMANDS->{$command}}) {
            if ($_ =~ /commandline/) {
                my $command_line = $COMMANDS->{$command}->{$_}; # escape quotes

                # convert legacy runtime macros to 2.x
                $command_line = convert_legacy_command_macros_2x($command_line);

                # 1.x definition
                if ($command_line =~ /\$(USER\d+)\$/) {
                    $command_line = "\"".escape_str($command_line)."\""; # escape quotes
                }
                if ($command_line !~ /^"/) {
                    $command_line = "\"".escape_str($command_line)."\""; # escape quotes
                }
                print FH "\tcommand = $command_line\n";
            }
        }
        print FH "}\n";

        # close target file
        close(FH);
    }
}

#
# CONTACTS
#
sub genContacts {
    my $CONFIG = shift;
    my $target = shift;
    my $dir    = shift;
    my $outputDir;

    # set output dir
    if (defined $dir) { $outputDir = $dir; } else { $outputDir = $opt->{outputDir}; }

    # get all contacts
    my $CONTACTS = HashGrep($CONFIG, 'objectclass', $cfg->{ldap}->{prefix}.'Contact$');

    # check all contacts... are they below $cfg->{ldap}->{baseDN} ?
    # --> so contact objects in ou=Examples and ou=Templates will not be handled
    foreach my $val (keys %{$CONTACTS}) { delete $CONTACTS->{$val} if $val !~ /$cfg->{ldap}->{baseDN}$/; }

    # a special target is set?
    if (defined($target)) { foreach my $val (keys %{$CONTACTS}) { delete $CONTACTS->{$val} if $val !~ /$target$/; } }

    if (defined $cfg->{export}->{format} && $cfg->{export}->{format} == 2) {
        genContacts2x($CONTACTS, $outputDir);
    } else {
        genContacts1x($CONTACTS, $outputDir);
    }
}

sub genContacts1x {
    my $CONTACTS = shift;
    my $outputDir = shift;

    foreach my $contact (keys %{$CONTACTS}) {

        # get target file's name and open it for writing
        my $writeFile = BuildFilepath($CONTACTS->{$contact}->{dn}, $outputDir);
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

        print FH "define contact {\n";
        print FH "\tuse generic-contact\n";
        foreach(sort keys %{$CONTACTS->{$contact}}) {
            if ($itemMap{$_}) {
                if ($_ eq 'cn') {
                    print FH "\tcontact_name\t$CONTACTS->{$contact}->{$_}\n";
                } else {
                    print FH "\t$itemMap{$_}\t$CONTACTS->{$contact}->{$_}\n";
                }
            }
        }
        print FH "}\n";

        # close target file
        close(FH);

    }
}

sub genContacts2x {
    my $CONTACTS = shift;
    my $outputDir = shift;

    foreach my $contact (keys %{$CONTACTS}) {

        # get target file's name and open it for writing
        my $writeFile = BuildFilepath($CONTACTS->{$contact}->{dn}, $outputDir);
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

        print FH "object User \"$CONTACTS->{$contact}->{cn}\" {\n";
        print FH "\timport \"generic-user\"\n";
        if (defined $CONTACTS->{$contact}->{$cfg->{ldap}->{prefix}.'alias'}) {
            print FH "\tdisplay_name = \"$CONTACTS->{$contact}->{$cfg->{ldap}->{prefix}.'alias'}\"\n";
        } else {
            print FH "\tdisplay_name = \"$CONTACTS->{$contact}->{cn}\"\n";
        }

        foreach(sort keys %{$CONTACTS->{$contact}}) {
            if ($_ !~ /pager/ && $_ =~ /address/ && $_ !~ /email/) {
                print FH "\tvars.$itemMapIcinga2{$_} = \"$CONTACTS->{$contact}->{$_}\"\n";
            }
        }

        foreach(sort keys %{$CONTACTS->{$contact}}) {
            if ($_ =~ /pager/ || $_ =~ /email/) {
                print FH "\t$itemMapIcinga2{$_} = \"$CONTACTS->{$contact}->{$_}\"\n";
            } elsif ($_ =~ /contactgroups/ ) {
                @groups = str2arr_by_delim_without_excludes($CONTACTS->{$contact}->{$_}, ',', 1);
                if (@groups) {
                    $contactstr = '["' . join( '","', @groups) . '"]';
                    print FH "\t$itemMapIcinga2{$_} = $contactstr\n";
                }
            }
        }

        print FH "}\n";

        # close target file
        close(FH);

    }
}

#
# CONTACTGROUPS
#
sub genContactgroups {
    my $CONFIG = shift;
    my $target = shift;
    my $dir    = shift;
    my $outputDir;

    # set output dir
    if (defined $dir) { $outputDir = $dir; } else { $outputDir = $opt->{outputDir}; }

    # get all contactgroups
    my $CONTACTGROUPS = HashGrep($CONFIG, 'objectclass', $cfg->{ldap}->{prefix}.'Contactgroup');

    # check all contactgroups... are they below $cfg->{ldap}->{baseDN} ?
    # --> so contactgroup objects in ou=Examples and ou=Templates will not be handled
    foreach my $val (keys %{$CONTACTGROUPS}) { delete $CONTACTGROUPS->{$val} if $val !~ /$cfg->{ldap}->{baseDN}$/; }

    # a special target is set?
    if (defined($target)) { foreach my $val (keys %{$CONTACTGROUPS}) { delete $CONTACTGROUPS->{$val} if $val !~ /$target$/; } }

    if (defined $cfg->{export}->{format} && $cfg->{export}->{format} == 2) {
        genContactgroups2x($CONTACTGROUPS, $outputDir);
    } else {
        genContactgroups1x($CONTACTGROUPS, $outputDir);
    }
}

sub genContactgroups1x {
    my $CONTACTGROUPS = shift;
    my $outputDir = shift;

    foreach my $contactgroup (keys %{$CONTACTGROUPS}) {

        # get target file's name and open it for writing
        my $writeFile = BuildFilepath($CONTACTGROUPS->{$contactgroup}->{dn}, $outputDir);
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

        print FH "define contactgroup {\n";
        foreach (sort keys %{$CONTACTGROUPS->{$contactgroup}}) {
            if ($itemMap{$_}) {
                if ($_ eq 'cn') {
                    print FH "\tcontactgroup_name\t$CONTACTGROUPS->{$contactgroup}->{$_}\n";
                } else {
                    print FH "\t$itemMap{$_}\t$CONTACTGROUPS->{$contactgroup}->{$_}\n";
                }
            }
        }

        if (defined $CONTACTGROUPS->{$contactgroup}->{$cfg->{ldap}->{prefix}.'contactgroupmembers'}) {
            my @groups = split(',', $CONTACTGROUPS->{$contactgroup}->{$cfg->{ldap}->{prefix}.'contactgroupmembers'});
            my $groups = join ",", grep length,  @groups;
            print FH "\tcontactgroup_members\t$groups\n";
        }

        print FH "}\n";

        # close target file
        close(FH);
    }
}

sub genContactgroups2x {
    my $CONTACTGROUPS = shift;
    my $outputDir = shift;

    foreach my $contactgroup (keys %{$CONTACTGROUPS}) {

        # get target file's name and open it for writing
        my $writeFile = BuildFilepath($CONTACTGROUPS->{$contactgroup}->{dn}, $outputDir);
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

        print FH "object UserGroup \"$CONTACTGROUPS->{$contactgroup}->{cn}\" {\n";
        if (defined $CONTACTGROUPS->{$contactgroup}->{$cfg->{ldap}->{prefix}.'alias'}) {
            print FH "\tdisplay_name = \"$CONTACTGROUPS->{$contactgroup}->{$cfg->{ldap}->{prefix}.'alias'}\"\n";
        } else {
            print FH "\tdisplay_name = \"$CONTACTGROUPS->{$contactgroup}->{cn}\"\n";
        }

        if (defined $CONTACTGROUPS->{$contactgroup}->{$cfg->{ldap}->{prefix}.'contactgroupmembers'}) {
            my @groups = split(',', $CONTACTGROUPS->{$contactgroup}->{$cfg->{ldap}->{prefix}.'contactgroupmembers'});
            my $groups = join ",", grep length,  @groups;
            $groups =~ s/,/\", \"/g;
            print FH "\tgroups = [ \"$groups\" ]\n";
        }

        if (defined $CONTACTGROUPS->{$contactgroup}->{$cfg->{ldap}->{prefix}.'members'}) {
            @members = str2arr_by_delim_without_excludes($CONTACTGROUPS->{$contactgroup}->{$cfg->{ldap}->{prefix}.'members'}, ',', 1);
            if (@members) {
                $membersstr = '["' . join( '","', @members) . '"]';
                print FH "\tassign where user.name in $membersstr\n";
            }
        }

        print FH "}\n";

        # close target file
        close(FH);
    }
}

#
# HOSTGROUPS
#
sub genHostgroups {
    my $CONFIG  = shift;
    my $CLIENTS = shift;
    my $target  = shift;
    my $dir    = shift;
    my $outputDir;

    # set output dir
    if (defined $dir) { $outputDir = $dir; } else { $outputDir = $opt->{outputDir}; }

    # get all hostgroups defined by hostgroup object
    my $HOSTGROUPS = HashGrep($CONFIG, 'objectclass', $cfg->{ldap}->{prefix}.'Hostgroup');
    #DebugOutput("GENERATE HOSTGROUPCONFIG", Dumper($HOSTGROUPS), 1);

    # check all hostgroups... are they below $cfg->{ldap}->{baseDN} ?
    # --> so hostgroups objects in ou=Examples and ou=Templates will not be handled
    foreach my $val (keys %{$HOSTGROUPS}) { delete $HOSTGROUPS->{$val} if $val !~ /$cfg->{ldap}->{baseDN}$/; }

    # a special target is set?
    if (defined($target)) { foreach my $val (keys %{$HOSTGROUPS}) { delete $HOSTGROUPS->{$val} if $val !~ /$target$/; } }

    # process hostgroups by hostgroup object
    foreach my $hostgroup (keys %{$HOSTGROUPS}) {

        # if there are 'member'-attributes, push the values to $CLIENT hash
        if (defined $HOSTGROUPS->{$hostgroup}->{$cfg->{ldap}->{prefix}.'members'}) {

            # multiple values? split...
            my @hosts = split(/\,/, $HOSTGROUPS->{$hostgroup}->{$cfg->{ldap}->{prefix}.'members'});
            foreach my $host (@hosts) {

                # find the right host
                my $tmp_hash = HashGrep($CLIENTS, 'objectclass', $cfg->{ldap}->{prefix}.'Host');
                my $hostsearch = HashGrep($tmp_hash, 'dn', '^cn='.$host.',');
                foreach my $val1 (keys %{$hostsearch}) {
                    if (defined $CLIENTS->{$val1}->{$cfg->{ldap}->{prefix}.'hostgroups'}) {
                        $CLIENTS->{$val1}->{$cfg->{ldap}->{prefix}.'hostgroups'} .= ','.$HOSTGROUPS->{$hostgroup}->{cn};
                    } else {
                        $CLIENTS->{$val1}->{$cfg->{ldap}->{prefix}.'hostgroups'} .= $HOSTGROUPS->{$hostgroup}->{cn};
                    }

                    # TODO if there are escalations for this hostgroup, add them to the host itsself (Icinga 2.x)
                }
            }
        }

        # generate hostgroup host escalations
        genHostgroupEscalations($CONFIG, $CLIENTS, $outputDir, $hostgroup);
    }

    # get all hostgroups defined by hostobject
    foreach my $client (keys %{$CLIENTS}) {
        if (defined $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostgroups"}) {

            # 1.) add a dummy hostgroup if there was an unknown hostgroup referenced
            # 2.) look for host's hostgroups and their services below

            my $groups_str = $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostgroups"};
            my @hhgs = str2arr_by_delim_without_excludes($groups_str, ',', 0);

            foreach my $hg (@hhgs) {

                # ignore empty values from split

                # find the right hostgroup
                my $hostgroup = HashGrep($HOSTGROUPS, 'dn', '^cn='.$hg.',');

                # only one, but we'll get a hash anyways
                my $group_found = undef;
                foreach my $hostgroupdn (keys %{$hostgroup}) {

                    DebugOutput("GENERATE HOSTGROUPCONFIG", "Generate host services for hostgroup '$hg'", 1);

                    # look for services below hostgroup
                    my $hg_result = HashGrep($CONFIG, 'dn', '^[\w]+=[._\w\/\d\s:-]+,'.$hostgroupdn);
                    my $HOSTGROUPSERVICES = HashGrep($hg_result, 'objectclass', $cfg->{ldap}->{prefix}.'Service$');
                    foreach my $service (keys %{$HOSTGROUPSERVICES}) {
                        DebugOutput("GENERATE HOSTGROUPCONFIG", " HostDN: '$client'", 1);
                        DebugOutput("GENERATE HOSTGROUPCONFIG", " ServiceDN: '$service'", 1);

                        # we'll override all host SERVICES if there are duplicates
                        # clone the hash to prevent wrong references on dumping host services
                        $CLIENTS->{$client}->{SERVICES}->{$HOSTGROUPSERVICES->{$service}->{'cn'}} = dclone($HOSTGROUPSERVICES->{$service});
                    }

                    $group_found = 1;
                }

                # what happens if that hostgroup does not exist? -> create a dummy
                if (!defined($group_found)) {
                    $HOSTGROUPS->{$hg}->{cn} = $hg;
                }

            }
        }
    }

    if (defined $cfg->{export}->{format} && $cfg->{export}->{format} == 2) {
        genHostgroups2x($HOSTGROUPS, $outputDir);
    } else {
        genHostgroups1x($HOSTGROUPS, $outputDir);
    }
}

sub genHostgroups1x {
    my $HOSTGROUPS = shift;
    my $outputDir = shift;

    # write hostgroup files
    foreach my $hostgroup (keys %{$HOSTGROUPS}) {

        # set file path
        my $writeFile = $outputDir."/hostgroups/$HOSTGROUPS->{$hostgroup}->{cn}.cfg";

        # open target file
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";
        print FH "define hostgroup {\n";
        print FH "\thostgroup_name\t$HOSTGROUPS->{$hostgroup}->{cn}\n";
        if (defined $HOSTGROUPS->{$hostgroup}->{$cfg->{ldap}->{prefix}.'alias'}) {
            print FH "\talias\t$HOSTGROUPS->{$hostgroup}->{$cfg->{ldap}->{prefix}.'alias'}\n";
        } else {
            print FH "\talias\t$HOSTGROUPS->{$hostgroup}->{cn}\n";
        }

        if (defined $HOSTGROUPS->{$hostgroup}->{$cfg->{ldap}->{prefix}.'hostgroupmembers'}) {
            my @groups = split(',', $HOSTGROUPS->{$hostgroup}->{$cfg->{ldap}->{prefix}.'hostgroupmembers'});
            my $groups = join ",", grep length,  @groups;
            print FH "\thostgroup_members\t$groups\n";
        }

        print FH "}\n";

        # close target file
        close(FH);
    }
}

sub genHostgroups2x {
    my $HOSTGROUPS = shift;
    my $outputDir = shift;

    #DebugOutput("GENERATE HOSTGROUPCONFIG", Dumper($HOSTGROUPS), 1);

    # write hostgroup files
    foreach my $hostgroup (keys %{$HOSTGROUPS}) {

        # set file path
        my $writeFile = $outputDir."/hostgroups/$HOSTGROUPS->{$hostgroup}->{cn}.conf";

        # open target file
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";
        print FH "object HostGroup \"$HOSTGROUPS->{$hostgroup}->{cn}\" {\n";
        if (defined $HOSTGROUPS->{$hostgroup}->{$cfg->{ldap}->{prefix}.'alias'}) {
            print FH "\tdisplay_name = \"$HOSTGROUPS->{$hostgroup}->{$cfg->{ldap}->{prefix}.'alias'}\"\n";
        } else {
            print FH "\tdisplay_name = \"$HOSTGROUPS->{$hostgroup}->{cn}\"\n";
        }

        if (defined $HOSTGROUPS->{$hostgroup}->{$cfg->{ldap}->{prefix}.'hostgroupmembers'}) {
            my @groups = split(',', $HOSTGROUPS->{$hostgroup}->{$cfg->{ldap}->{prefix}.'hostgroupmembers'});
            my $groups = join ",", grep length,  @groups;
            $groups =~ s/,/\", \"/g;
            print FH "\tgroups = [ \"$groups\" ]\n";
        }

        print FH "}\n";

        # close target file
        close(FH);
    }
}

sub genHostgroupEscalations {
    my $CONFIG  = shift;
    my $CLIENTS = shift;
    my $outputDir = shift;
    my $hostgroup = shift;

    if (defined $cfg->{export}->{format} && $cfg->{export}->{format} == 2) {
        genHostgroupEscalations2x($CONFIG, $CLIENTS, $hostgroup, $outputDir);
    } else {
        genHostgroupEscalations1x($CONFIG, $hostgroup, $outputDir);
    }
}

sub genHostgroupEscalations1x {
    my $CONFIG  = shift;
    my $hostgroup = shift;
    my $outputDir = shift;

    # Search for escalations below of a hostgroupgroup
    my $he_result = HashGrep($CONFIG, 'dn', '^[\w]+=[._\w\/\d\s:-]+,'.$hostgroup);
    my $HOSTESCALATIONS = HashGrep($he_result, 'objectclass', $cfg->{ldap}->{prefix}.'hostescalation$');

    foreach my $escalation (keys %{$HOSTESCALATIONS}) {
        my $writeFile = $outputDir."/hostescalations/$he_result->{$escalation}->{cn}.cfg";

        # open target file
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";
        print FH "define hostescalation {\n";
        print FH "\t$itemMap{lconfhostescalationhostgroups}\t$CONFIG->{$hostgroup}->{cn}\n";

        foreach my $val1 (sort keys %{$he_result->{$escalation}}) {
            if ($val1 =~ /$cfg->{ldap}->{prefix}hostescalation/) {
                print FH "\t$itemMap{$val1}\t$he_result->{$escalation}->{$val1}\n";
            }
        }
        print FH "}\n\n";

        # close target file
        close(FH);
    }
}

#FIXME stash escalations as host notifications for each host inside the hostgroup (see above)
sub genHostgroupEscalations2x {
    my $CONFIG  = shift;
    my $CLIENTS = shift;
    my $hostgroup = shift;
    my $outputDir = shift;

    # Search for escalations below of a hostgroupgroup
    my $he_result = HashGrep($CONFIG, 'dn', '^[\w]+=[._\w\/\d\s:-]+,'.$hostgroup);
    my $HOSTESCALATIONS = HashGrep($he_result, 'objectclass', $cfg->{ldap}->{prefix}.'hostescalation$');

    foreach my $escalation (keys %{$HOSTESCALATIONS}) {

=pod
        my $writeFile = $outputDir."/hostescalations/$he_result->{$escalation}->{cn}.cfg";

        # open target file
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";
        print FH "define hostescalation {\n";
        print FH "\t$itemMap{lconfhostescalationhostgroups}\t$CONFIG->{$hostgroup}->{cn}\n";

        foreach my $val1 (sort keys %{$he_result->{$escalation}}) {
            if ($val1 =~ /$cfg->{ldap}->{prefix}hostescalation/) {
                print FH "\t$itemMap{$val1}\t$he_result->{$escalation}->{$val1}\n";
            }
        }
        print FH "}\n\n";

        # close target file
        close(FH);
=cut

    }
}

#
# SERVICEGROUPS
#
sub genServicegroups {
    my $CONFIG  = shift;
    my $CLIENTS = shift;
    my $target  = shift;
    my $dir     = shift;
    my $outputDir;

    # set output dir
    if (defined $dir) { $outputDir = $dir; } else { $outputDir = $opt->{outputDir}; }

    # get all hostgroups defined by hostgroup object
    my $SERVICEGROUPS = HashGrep($CONFIG, 'objectclass', $cfg->{ldap}->{prefix}.'Servicegroup');

    # check all servicegroups... are they below $cfg->{ldap}->{baseDN} ?
    # --> so servicegroups objects in ou=Examples and ou=Templates will not be handled
    foreach my $val (keys %{$SERVICEGROUPS}) { delete $SERVICEGROUPS->{$val} if $val !~ /$cfg->{ldap}->{baseDN}$/; }

    # a special target is set?
    if (defined($target)) { foreach my $val (keys %{$SERVICEGROUPS}) { delete $SERVICEGROUPS->{$val} if $val !~ /$target$/; } }

    # process servicegroups
    foreach my $servicegroup (keys %{$SERVICEGROUPS}) {

        # if there are 'member'-attributes, push the values to $CLIENT hash
        if (defined $SERVICEGROUPS->{$servicegroup}->{$cfg->{ldap}->{prefix}.'members'}) {
            my @val = split(/\s*,\s*/, $SERVICEGROUPS->{$servicegroup}->{"$cfg->{ldap}->{prefix}members"});
            my $counter = 0;

            while($counter <= $#val) {

                # search full name in client hash :(
                foreach my $client (keys %{$CLIENTS}) {

                    # if real name was found, add to $CLIENT hash
                    if ($client =~ /^cn=$val[$counter],/) {
                        if ($CLIENTS->{$client}->{SERVICES}->{$val[$counter+1]}->{"$cfg->{ldap}->{prefix}servicegroups"}) {
                            $CLIENTS->{$client}->{SERVICES}->{$val[$counter+1]}->{"$cfg->{ldap}->{prefix}servicegroups"} = $CLIENTS->{$client}->{SERVICES}->{$val[$counter+1]}->{"$cfg->{ldap}->{prefix}servicegroups"}.','.$result->{$servicegroup}->{'cn'};
                        } else {
                            $CLIENTS->{$client}->{SERVICES}->{$val[$counter+1]}->{"$cfg->{ldap}->{prefix}servicegroups"} = $SERVICEGROUPS->{$servicegroup}->{'cn'};
                        }

                        # TODO find service escalations below servicegroup and add to services as notification with begin/end time
                    }
                }

                $counter = $counter+2;
            }
        }

        # look for service escalations below servicegroup
        genServicegroupEscalations($CONFIG, $CLIENTS, $outputDir, $servicegroup);
    }

    # get all servicegroups defined by serviceobject
    foreach my $client (keys %{$CLIENTS}) {
        foreach my $service (keys %{$CLIENTS->{$client}->{SERVICES}}) {
            if (defined $CLIENTS->{$client}->{SERVICES}->{$service}->{"$cfg->{ldap}->{prefix}servicegroups"}) {

                # multiple or a single servicegroup?
                if ($CLIENTS->{$client}->{SERVICES}->{$service}->{"$cfg->{ldap}->{prefix}servicegroups"} =~ /,/) {
                    my @val = split(/\s*,\s*/, $CLIENTS->{$client}->{SERVICES}->{$service}->{"$cfg->{ldap}->{prefix}servicegroups"});
                    foreach(@val) { $SERVICEGROUPS->{$_}->{cn} = $_ if $_ ne ''; }
                } else {
                    $SERVICEGROUPS->{$CLIENTS->{$client}->{SERVICES}->{$service}->{"$cfg->{ldap}->{prefix}servicegroups"}}->{cn} = $CLIENTS->{$client}->{SERVICES}->{$service}->{"$cfg->{ldap}->{prefix}servicegroups"};
                }
            }
        }
    }

    if (defined $cfg->{export}->{format} && $cfg->{export}->{format} == 2) {
        genServicegroups2x($SERVICEGROUPS, $outputDir);
    } else {
        genServicegroups1x($SERVICEGROUPS, $outputDir);
    }
}

sub genServicegroups1x {
    my $SERVICEGROUPS = shift;
    my $outputDir = shift;

    # write servicegroup files
    foreach my $servicegroup (keys %{$SERVICEGROUPS}) {

        # set file path
        my $writeFile = $outputDir."/servicegroups/$SERVICEGROUPS->{$servicegroup}->{cn}.cfg";

        # open target file
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";
        print FH "define servicegroup {\n";
        print FH "\tservicegroup_name\t$SERVICEGROUPS->{$servicegroup}->{cn}\n";
        if (defined $SERVICEGROUPS->{$servicegroup}->{$cfg->{ldap}->{prefix}.'alias'}) {
            print FH "\talias\t$SERVICEGROUPS->{$servicegroup}->{$cfg->{ldap}->{prefix}.'alias'}\n";
        } else {
            print FH "\talias\t$SERVICEGROUPS->{$servicegroup}->{cn}\n";
        }

        if (defined $SERVICEGROUPS->{$servicegroup}->{$cfg->{ldap}->{prefix}.'servicegroupmembers'}) {
            my @groups = split(',', $SERVICEGROUPS->{$servicegroup}->{$cfg->{ldap}->{prefix}.'servicegroupmembers'});
            my $groups = join ",", grep length,  @groups;
            print FH "\thostgroup_members\t$groups\n";
        }

        print FH "}\n";

        # close target file
        close(FH);
    }
}

sub genServicegroups2x {
    my $SERVICEGROUPS = shift;
    my $outputDir = shift;

    # write servicegroup files
    foreach my $servicegroup (keys %{$SERVICEGROUPS}) {

        # set file path
        my $writeFile = $outputDir."/servicegroups/$SERVICEGROUPS->{$servicegroup}->{cn}.conf";

        # open target file
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";
        print FH "object ServiceGroup \"$SERVICEGROUPS->{$servicegroup}->{cn}\" {\n";
        if (defined $SERVICEGROUPS->{$servicegroup}->{$cfg->{ldap}->{prefix}.'alias'}) {
            print FH "\tdisplay_name = \"$SERVICEGROUPS->{$servicegroup}->{$cfg->{ldap}->{prefix}.'alias'}\"\n";
        } else {
            print FH "\tdisplay_name = \"$SERVICEGROUPS->{$servicegroup}->{cn}\"\n";
        }

        if (defined $SERVICEGROUPS->{$servicegroup}->{$cfg->{ldap}->{prefix}.'servicegroupmembers'}) {
            my @groups = split(',', $SERVICEGROUPS->{$servicegroup}->{$cfg->{ldap}->{prefix}.'servicegroupmembers'});
            my $groups = join ",", grep length,  @groups;
            $groups =~ s/,/\", \"/g;
            print FH "\tgroups = [ \"$groups\" ]\n";
        }

        print FH "}\n";

        # close target file
        close(FH);
    }
}

sub genServicegroupEscalations {
    my $CONFIG  = shift;
    my $CLIENTS = shift;
    my $outputDir = shift;
    my $servicegroup = shift;

    if (defined $cfg->{export}->{format} && $cfg->{export}->{format} == 2) {
        genServicegroupEscalations2x($CONFIG, $CLIENTS, $servicegroup, $outputDir);
    } else {
        genServicegroupEscalations1x($CONFIG, $servicegroup, $outputDir);
    }
}

sub genServicegroupEscalations1x {
    my $CONFIG  = shift;
    my $outputDir = shift;
    my $servicegroup = shift;

    # Search for escalations below of a servicegroup
    my $se_result = HashGrep($CONFIG, 'dn', '^[\w]+=[._\w\/\d\s:-]+,'.$servicegroup);
    my $SERVICEESCALATIONS = HashGrep($se_result, 'objectclass', $cfg->{ldap}->{prefix}.'serviceescalation$');

    foreach my $escalation (keys %{$SERVICEESCALATIONS}) {
        my $writeFile = $outputDir."/serviceescalations/$se_result->{$escalation}->{cn}.cfg";

        # open target file
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";
        print FH "define serviceescalation {\n";
        print FH "\t$itemMap{lconfserviceescalationservicegroups}\t$CONFIG->{$servicegroup}->{cn}\n";

        foreach my $val1 (sort keys %{$se_result->{$escalation}}) {
            if ($val1 =~ /$cfg->{ldap}->{prefix}serviceescalation/) {
                print FH "\t$itemMap{$val1}\t$se_result->{$escalation}->{$val1}\n";
            }
        }
        print FH "}\n\n";

        # close target file
        close(FH);
    }
}

sub genServicegroupEscalations2x {
    my $CONFIG  = shift;
    my $CLIENTS = shift;
    my $outputDir = shift;
    my $servicegroup = shift;

    # Search for escalations below of a servicegroup
    my $se_result = HashGrep($CONFIG, 'dn', '^[\w]+=[._\w\/\d\s:-]+,'.$servicegroup);
    my $SERVICEESCALATIONS = HashGrep($se_result, 'objectclass', $cfg->{ldap}->{prefix}.'serviceescalation$');

=pod
    foreach my $escalation (keys %{$SERVICEESCALATIONS}) {
        my $writeFile = $outputDir."/serviceescalations/$se_result->{$escalation}->{cn}.cfg";

        # open target file
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";
        print FH "define serviceescalation {\n";
        print FH "\t$itemMap{lconfserviceescalationservicegroups}\t$CONFIG->{$servicegroup}->{cn}\n";

        foreach my $val1 (sort keys %{$se_result->{$escalation}}) {
            if ($val1 =~ /$cfg->{ldap}->{prefix}serviceescalation/) {
                print FH "\t$itemMap{$val1}\t$se_result->{$escalation}->{$val1}\n";
            }
        }
        print FH "}\n\n";

        # close target file
        close(FH);
    }
=cut

}

#
# ESCALATIONS
#

#
# HOSTS
#
sub genHostConfig {
    my $CONFIG  = shift;
    my $CLIENTS = shift;
    my $client = shift;
    my $dir    = shift;
    my $outputDir;

    # set output dir
    if (defined $dir) { $outputDir = $dir; } else { $outputDir = $opt->{outputDir}; }

    if (defined $cfg->{export}->{format} && $cfg->{export}->{format} == 2) {
        genHostConfig2x($CONFIG, $CLIENTS, $client, $outputDir);
    } else {
        genHostConfig1x($CONFIG, $CLIENTS, $client, $outputDir);
    }
}

sub genHostConfig1x {
    my $CONFIG  = shift;
    my $CLIENTS = shift;
    my $client = shift;
    my $outputDir = shift;

    DebugOutput("GENERATE HOSTCONFIG 1x", "Generate config for $client", 1);
    if (defined $CLIENTS->{$client}->{dn}) {

        # only gen config if lconfhostdisable is not set
        if (!defined $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostdisable"}) {
            #
            # HOST DEFINITION
            #
            # get target file's name and open it for writing
            my $writeFile = BuildFilepath($CLIENTS->{$client}->{dn}, $outputDir);
            open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

            # generate host definition
            print FH "define host {\n";
            print FH "\tuse generic-host\n";
            print FH "\thost_name\t$CLIENTS->{$client}->{cn}\n";

            # process each item...
            foreach my $val1 (sort keys %{$CLIENTS->{$client}}) {

                # ...but look after type; only host items
                # and no service dependency attributes;
                # they will be handled in an other way
                if (($val1 =~ /$cfg->{ldap}->{prefix}host/ ||
                     $val1 eq "$cfg->{ldap}->{prefix}address" ||
                     $val1 eq "$cfg->{ldap}->{prefix}address6" ||
                     $val1 eq "$cfg->{ldap}->{prefix}parent" ||
                     $val1 eq "$cfg->{ldap}->{prefix}alias") &&
                     $val1 !~ /$cfg->{ldap}->{prefix}hostdependency/) {

                    # compatibility hack for nagios address6
                    if ($val1 eq "$cfg->{ldap}->{prefix}address6" && defined $cfg->{export}->{format} && $cfg->{export}->{format} == 0) {
                        print FH "\t_ADDRESS6\t$CLIENTS->{$client}->{$val1}\n";
                        next;
                    }

                    # customvar or a default item?
                    if ($val1 =~ /customvar/i) {
                        foreach my $val2 (sort keys %{$CLIENTS->{$client}->{$val1}}) {
                            print FH "\t$val2\t$CLIENTS->{$client}->{$val1}->{$val2}\n";
                        }
                    } else {
                        if ($itemMap{$val1} =~ /contact_groups/i) {
                            my @groups = split(',', $CLIENTS->{$client}->{$val1});
                            my $groups = join ",", grep length,  @groups;
                            print FH "\t$itemMap{$val1}\t$groups\n";
                        } else {
                            print FH "\t$itemMap{$val1}\t$CLIENTS->{$client}->{$val1}\n";
                        }
                    }
                }
            }

            # generate end of host definition
            print FH "}\n";
            print FH "\n";

            #
            # SERVICES
            #
            foreach my $service (keys %{$CLIENTS->{$client}->{'SERVICES'}}) {
                DebugOutput("GENERATE HOSTCONFIG", "Found service $service", 1);

                # only gen service if lconfservicedisable is not set
                if (!defined $CLIENTS->{$client}->{'SERVICES'}->{$service}->{"$cfg->{ldap}->{prefix}servicedisable"}) {
                    print FH "define service {\n";
                    print FH "\tuse generic-service\n";
                    print FH "\tservice_description\t$CLIENTS->{$client}->{'SERVICES'}->{$service}->{cn}\n";
                    print FH "\thost_name\t$CLIENTS->{$client}->{cn}\n";

                    # process each item
                    foreach my $val1 (sort keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}}) {

                        # ...but look after type; only service items!
                        if (($val1 =~ /$cfg->{ldap}->{prefix}service/ || $val1 eq "$cfg->{ldap}->{prefix}checkcommand") && $val1 !~ /$cfg->{ldap}->{prefix}servicedependency/) {

                            # customvar or a default item?
                            if ($val1 =~ /customvar/i) {
                                foreach my $val2 (sort keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}}) {
                                    next if (!defined($val2) ||
                                            $val2 eq "" ||
                                            $val2 eq "_" ||
                                            !defined($CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}->{$val2}) ||
                                            $CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}->{$val2} eq "");
                                    print FH "\t$val2\t$CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}->{$val2}\n";
                                }
                            } else {
                                if ($itemMap{$val1} =~ /contact_groups/i) {
                                    my @groups = split(',', $CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1});
                                    my $groups = join ",", grep length,  @groups;
                                    print FH "\t$itemMap{$val1}\t$groups\n";
                                } else {
                                    print FH "\t$itemMap{$val1}\t$CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}\n";
                                }
                            }
                        }
                    }

                    print FH "}\n";
                    print FH "\n";
                } else {
                    DebugOutput("GENERATE HOSTCONFIG 1x", "Skipping disabled service '$service' ", 1);
                }
            }

            #
            # HOST DEPENDENCIES
            #
            foreach my $dependency (sort keys %{$CLIENTS->{$client}->{'HOSTDEPENDENCY'}}) {

                # only if host is not disabled
                if (!$CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostdisable"}) {
                    print FH "define hostdependency {\n";
                    print FH "\thost_name\t$dependency\n";
                    print FH "\tdependent_host_name\t$CLIENTS->{$client}->{cn}\n";
                    foreach(sort keys %{$CLIENTS->{$client}->{HOSTDEPENDENCY}->{$dependency}}) {
                        print FH "\t$itemMap{$_}\t$CLIENTS->{$client}->{HOSTDEPENDENCY}->{$dependency}->{$_}\n" if $itemMap{$_};
                    }
                    print FH "}\n";
                    print FH "\n";
                }
            }

            #
            # SERVICE DEPENDENCIES
            #
            foreach my $service (sort keys %{$CLIENTS->{$client}->{'SERVICES'}}) {

                # only gen service if lconfservicedisable is not set
                if (!defined $CLIENTS->{$client}->{'SERVICES'}->{$service}->{"$cfg->{ldap}->{prefix}servicedisable"}) {
                    if (defined $CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEDEPENDENCY}) {
                        foreach my $dependency (sort keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEDEPENDENCY}}) {
                            my ($depHost, $depService) = (split(/ *-> */, $dependency))[0,1];

                            print FH "define servicedependency {\n";

                            # special stuff for inheritance :-(
                            if ($depHost eq "\$HOSTNAME\$") {
                                print FH "\thost_name\t$CLIENTS->{$client}->{cn}\n";
                            } else {
                                print FH "\thost_name\t$depHost\n";
                            }

                            print FH "\tservice_description\t$depService\n";
                            print FH "\tdependent_host_name\t$CLIENTS->{$client}->{cn}\n";
                            print FH "\tdependent_service_description\t$service\n";
                            foreach (sort keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEDEPENDENCY}->{$dependency}}) {
                                print FH "\t$itemMap{$_}\t$CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEDEPENDENCY}->{$dependency}->{$_}\n";
                            }
                            print FH "}\n";
                            print FH "\n";
                        }
                    }
                }
            }

            #
            # HOST ESCALATIONS
            #
            foreach my $escalation (sort keys %{$CLIENTS->{$client}->{'HOSTESCALATION'}}) {

                # only if host is not disabled
                if (!$CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostdisable"}) {
                    print FH "define hostescalation {\n";
                    print FH "\thost_name\t$CLIENTS->{$client}->{cn}\n";
                    foreach my $val (keys %{$CLIENTS->{$client}->{HOSTESCALATION}->{$escalation}}) {
                        print FH "\t$itemMap{$val}\t$CLIENTS->{$client}->{HOSTESCALATION}->{$escalation}->{$val}\n";
                    }
                    print FH "}\n";
                    print FH "\n";
                }
            }

            #
            # SERVICE ESCALATIONS
            #
            foreach my $service (sort keys %{$CLIENTS->{$client}->{'SERVICES'}}) {

                # only gen service if lconfservicedisable is not set
                if (!defined $CLIENTS->{$client}->{'SERVICES'}->{$service}->{"$cfg->{ldap}->{prefix}servicedisable"}) {
                    if (defined $CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEESCALATION}) {
                        foreach my $escalation (sort keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEESCALATION}}) {
                            print FH "define serviceescalation {\n";
                            print FH "\thost_name\t$CLIENTS->{$client}->{cn}\n";
                            print FH "\tservice_description\t$service\n";
                            foreach my $val (keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEESCALATION}->{$escalation}}) {
                                print FH "\t$itemMap{$val}\t$CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEESCALATION}->{$escalation}->{$val}\n";
                            }
                            print FH "}\n";
                            print FH "\n";
                        }
                    }
                }
            }
        } else {
            DebugOutput("GENERATE HOSTCONFIG 1x", "Skipping disabled host '$client' ", 1);
        }
    }
}

sub genHostConfig2x {
    my $CONFIG  = shift;
    my $CLIENTS = shift;
    my $client = shift;
    my $outputDir = shift;

    DebugOutput("GENERATE HOSTCONFIG 2x", "Generate config for $client", 1);

    # prepare contacts, contactgroups and commands once for later notification/eventhandler magic
    my $CONTACTGROUPS = HashGrep($CONFIG, 'objectclass', $cfg->{ldap}->{prefix}.'Contactgroup');
    my $CONTACTS = HashGrep($CONFIG, 'objectclass', $cfg->{ldap}->{prefix}.'Contact$');
    my $COMMANDS = HashGrep($CONFIG, 'objectclass', $cfg->{ldap}->{prefix}.'Command$');

    my $notification_commands = ();
    my $event_commands = ();

    if (defined $CLIENTS->{$client}->{dn}) {

        # only gen config if lconfhostdisable is not set
        if (!defined $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostdisable"}) {

            my $host = $CLIENTS->{$client}->{cn};
            #
            # HOST DEFINITION
            #
            my $vars = ();

            # get target file's name and open it for writing
            my $writeFile = BuildFilepath($CLIENTS->{$client}->{dn}, $outputDir);
            open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

            # generate host definition
            print FH "object Host \"$CLIENTS->{$client}->{cn}\" {\n";
            print FH "\timport \"generic-host\"\n";

            my $host_parents_str = "";

            # process each item...
            foreach my $val1 (sort keys %{$CLIENTS->{$client}}) {
                if ($val1 eq "$cfg->{ldap}->{prefix}hostcheckcommand" || $val1 eq "$cfg->{ldap}->{prefix}checkcommand") {

                    my $host_check_command_str = $CLIENTS->{$client}->{$val1};
                    my ($host_check_command_name, @host_check_command_args) = split /!/, $host_check_command_str;

                    my $arg_c = 1;
                    foreach my $macro_val (@host_check_command_args) {

                        # check command arg name for being an icinga 1.x macro and resolve its value
                        if ($macro_val =~ /^\$(\w+)\$$/) {
                            if ($1 =~ /^_HOST(\w+)/) {
                                my $cv_val_macro_key = "_".$1;

                                # override the original cv value
                                $macro_val = $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostcustomvar"}->{$cv_val_macro_key};
                            }
                        }

                        $vars->{'ARG'.$arg_c} = escape_str($macro_val);
                        $arg_c++;
                    }

                    print FH "\tcheck_command = \"$host_check_command_name\"\n";
                } elsif ($val1 eq "$cfg->{ldap}->{prefix}address" ||
                    $val1 eq "$cfg->{ldap}->{prefix}address6" ||
                    $val1 eq "$cfg->{ldap}->{prefix}hostactionurl" ||
                    $val1 eq "$cfg->{ldap}->{prefix}hostnotesurl" ||
                    $val1 eq "$cfg->{ldap}->{prefix}hostnotes" ||
                    $val1 eq "$cfg->{ldap}->{prefix}hosticonimage" ||
                    $val1 eq "$cfg->{ldap}->{prefix}hosticonimagealt"
                  ) {
                    print FH "\t$itemMapIcinga2{$val1} = \"$CLIENTS->{$client}->{$val1}\"\n";
                } elsif ($val1 eq "$cfg->{ldap}->{prefix}statusmapimage") {
                    $vars->{$itemMapIcinga2{$val1}} = escape_str($CLIENTS->{$client}->{$val1});
                } elsif ($val1 eq "$cfg->{ldap}->{prefix}hostcustomvar") {
                    foreach my $val2 (sort keys %{$CLIENTS->{$client}->{$val1}}) {
                        next if (!defined($val2) ||
                                $val2 eq "" ||
                                $val2 eq "_" ||
                                !defined($CLIENTS->{$client}->{$val1}->{$val2}) ||
                                $CLIENTS->{$client}->{$val1}->{$val2} eq "");
                        $key = $val2;
                        $key =~ s/_//;
                        $vars->{$key} = escape_str($CLIENTS->{$client}->{$val1}->{$val2});
                    }
                } elsif ($val1 eq "$cfg->{ldap}->{prefix}parent") {
                    $host_parents_str = $CLIENTS->{$client}->{$val1};
                } elsif ($val1 eq "$cfg->{ldap}->{prefix}hostgroups") {
                    my @groups = split(',', $CLIENTS->{$client}->{$val1});
                    my $groups = join ",", grep length, @groups;
                    $groups =~ s/,/\", \"/g;
                    print FH "\tgroups = [ \"$groups\" ]\n";
                } elsif ($val1 eq "$cfg->{ldap}->{prefix}alias" && !defined($CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostdisplayname"})) {
                    print FH "\tdisplay_name = \"$CLIENTS->{$client}->{$val1}\"\n";
                } elsif ($val1 eq "$cfg->{ldap}->{prefix}hostdisplayname") {
                    print FH "\tdisplay_name = \"$CLIENTS->{$client}->{$val1}\"\n";
                } elsif ($val1 eq "$cfg->{ldap}->{prefix}hostcheckperiod") {
                    print FH "\tcheck_period = \"$CLIENTS->{$client}->{$val1}\"\n";
                } elsif ($val1 eq "$cfg->{ldap}->{prefix}hostcheckinterval") {
                    print FH "\tcheck_interval = ".convert_interval_2x($CLIENTS->{$client}->{$val1})."\n";
                } elsif ($val1 eq "$cfg->{ldap}->{prefix}hostcheckretryinterval") {
                    print FH "\tretry_interval = ".convert_interval_2x($CLIENTS->{$client}->{$val1})."\n";
                } elsif ($val1 eq "$cfg->{ldap}->{prefix}hostcheckmaxcheckattempts") {
                    print FH "\tmax_check_attempts = $CLIENTS->{$client}->{$val1}\n";
                } elsif ($val1 eq "$cfg->{ldap}->{prefix}hostactivechecksenabled") {
                    print FH "\tenable_active_checks = $CLIENTS->{$client}->{$val1}\n";
                } elsif ($val1 eq "$cfg->{ldap}->{prefix}hostpassivechecksenabled") {
                    print FH "\tenable_passive_checks = $CLIENTS->{$client}->{$val1}\n";
                } elsif ($val1 eq "$cfg->{ldap}->{prefix}hostprocessperfdata") {
                    print FH "\tenable_perfdata = $CLIENTS->{$client}->{$val1}\n";
                } elsif ($val1 eq "$cfg->{ldap}->{prefix}hostnotificationsenabled") {
                    print FH "\tenable_notifications = $CLIENTS->{$client}->{$val1}\n";
                } elsif ($val1 eq "$cfg->{ldap}->{prefix}hostflapdetectionenabled") {
                    print FH "\tenable_flapping = $CLIENTS->{$client}->{$val1}\n";
                } elsif ($val1 eq "$cfg->{ldap}->{prefix}hosteventhandler") {
                    my ($event_command_name, @event_command_macros) = split /!/, "$CLIENTS->{$client}->{$val1}";

                    my $event_arg_c = 1;
                    foreach my $macro_val (@event_command_macros) {

                        # check command arg name for being an icinga 1.x macro and resolve its value
                        if ($macro_val =~ /^\$(\w+)\$$/) {
                            if ($1 =~ /^_HOST(\w+)/) {
                                my $cv_val_macro_key = "_".$1;

                                # override the original cv value with the resolved host cv
                                $macro_val = $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostcustomvar"}->{$cv_val_macro_key};
                            }
                        }

                        $vars->{'EVENTARG'.$event_arg_c} = escape_str($macro_val); # special prefix 'EVENTARG' for eventhandler arguments

                        $event_arg_c++;
                    }

                    my $event_command_object_name = "host-$CLIENTS->{$client}->{cn}-$event_command_name";

                    my $event_command_line;
                    foreach my $command (keys %{$COMMANDS}) {
                        if ($COMMANDS->{$command}->{cn} eq $event_command_name) {
                            $event_command_line = escape_str($COMMANDS->{$command}->{$cfg->{ldap}->{prefix}.'commandline'});

                            $event_command_line =~ s/ARG/EVENTARG/g; # required for eventhandler arguments

                            goto FOUND_EVENT;
                        }
                    }

                    FOUND_EVENT:

                    $event_commands->{$event_command_object_name} = $event_command_line;

                    print FH "\tevent_command = \"$event_command_object_name\",\n"
                }
            }

            # custom attr
            foreach my $var (sort keys %{$vars}) {
                print FH "\tvars.$var = \"$vars->{$var}\"\n"
            }

            # generate end of host definition
            print FH "}\n";
            print FH "\n";

            # host dependencies
            if (defined($CLIENTS->{$client}->{'HOSTDEPENDENCY'})) {
                foreach my $dependency (sort keys %{$CLIENTS->{$client}->{HOSTDEPENDENCY}}) {
                    next if (!defined $dependency || $dependency eq "");

                    print FH "object Dependency \"$dependency\" {\n";

                    print FH "\tparent_host_name = \"$dependency\"\n";
                    print FH "\tchild_host_name = \"$CLIENTS->{$client}->{cn}\"\n";

                    foreach(sort keys %{$CLIENTS->{$client}->{HOSTDEPENDENCY}->{$dependency}}) {
                        if ($_ eq "$cfg->{ldap}->{prefix}hostdependencyexecutionfailurecriteria") {
                            my $fail_crit = convert_dependendy_failure_criteria_2x($CLIENTS->{$client}->{HOSTDEPENDENCY}->{$dependency}->{$_}, 'check', 1);
                            DebugOutput("GENERATE HOSTCONFIG 2x", "HOSTDEPENDENCY exec: $CLIENTS->{$client}->{HOSTDEPENDENCY}->{$dependency}->{$_}: ".Dumper($fail_crit));
                            print FH "\tdisable_checks = true\n" if $fail_crit->{'runeverything'} == 0;
                            print FH "\tdisable_checks = false\n" if $fail_crit->{'runeverything'} == 1;
                            print FH "\tstates = [ ". (join ', ', @{$fail_crit->{'state'}}) ." ]\n"; # execution failure criteria is mandatory for state_filter
                        }
                        if ($_ eq "$cfg->{ldap}->{prefix}hostdependencynotificationfailurecriteria") {
                            my $fail_crit = convert_dependendy_failure_criteria_2x($CLIENTS->{$client}->{HOSTDEPENDENCY}->{$dependency}->{$_}, 'notification', 1);
                            DebugOutput("GENERATE HOSTCONFIG 2x", "HOSTDEPENDENCY notif: $CLIENTS->{$client}->{HOSTDEPENDENCY}->{$dependency}->{$_}: ".Dumper($fail_crit));
                            print FH "\tdisable_notifications = true\n" if $fail_crit->{'runeverything'} == 0;
                            print FH "\tdisable_notifications = false\n" if $fail_crit->{'runeverything'} == 1;
                        }
                    }
                    print FH "}\n";
                }
            }

            # 1.x parents are 2.x dependencies with no attributes
            my @parent_dependencies = ();
            if ($host_parents_str ne "") {
                push @parent_dependencies, str2arr_by_delim_without_excludes($host_parents_str, ',', 1);
            }

            if (@parent_dependencies > 0) {
                foreach my $parent_host (@parent_dependencies) {
                    print FH "object Dependency \"$parent_host\" {\n";
                    print FH "\tparent_host_name = \"$parent_host\"\n";
                    print FH "\tchild_host_name = \"$CLIENTS->{$client}->{cn}\"\n";
                    print FH "}\n";
                }
            }

            print FH "\n";

            #
            # host notifications
            #

            # parse contacts, contactgroups
            my @users = ();
            if (defined($CLIENTS->{$client}->{$cfg->{ldap}->{prefix}.'hostcontactgroups'})) {
                # yikes, comma separated groups string
                my $groups_str = $CLIENTS->{$client}->{$cfg->{ldap}->{prefix}.'hostcontactgroups'};

                DebugOutput("GENERATE HOSTCONFIG 2x", "Migrating contactgroups: '$groups_str' from host '$CLIENTS->{$client}->{cn}'.");
                my @groups = str2arr_by_delim_without_excludes($groups_str, ',', 0);

                # fetch all members from all contactgroups
                foreach my $group (@groups) {

                    # STAGE 1: get all contactgroup members which are matching
                    foreach my $contactgroup (keys %{$CONTACTGROUPS}) {
                        DebugOutput("GENERATE HOSTCONFIG 2x", "Generating Notifications, STAGE 1: Looking for contactgroup '$CONTACTGROUPS->{$contactgroup}->{cn}' members attribute.");

                        #DebugOutput("GENERATE HOSTCONFIG 2x", Dumper($CONTACTGROUPS->{$contactgroup}));
                        if ($CONTACTGROUPS->{$contactgroup}->{cn} eq $group) {
                            if (defined($CONTACTGROUPS->{$contactgroup}->{$cfg->{ldap}->{prefix}.'members'})) {
                                my @members = split /,/, $CONTACTGROUPS->{$contactgroup}->{$cfg->{ldap}->{prefix}.'members'};
                                push @users, @members;
                            }
                        }
                    }

                    # STAGE 2: loop over all contacts and compare if their groups match the requested one
                    foreach my $contact (keys %{$CONTACTS}) {
                        DebugOutput("GENERATE HOSTCONFIG 2x", "Generating Notifications, STAGE 2: Looking for contacts '$CONTACTS->{$contact}->{cn}' attribute contactgroups matching the current contactgroup '$group'.");
                        if (defined($CONTACTS->{$contact}->{$cfg->{ldap}->{prefix}.'contactgroups'})) {
                            DebugOutput("GENERATE HOSTCONFIG 2x", "contactgroups attribute found: '$CONTACTS->{$contact}->{$cfg->{ldap}->{prefix}.'contactgroups'}'. Matches '$group'?.");

                            # this is ugly, find a better match condition
                            if ($CONTACTS->{$contact}->{$cfg->{ldap}->{prefix}.'contactgroups'} =~ /$group/) {
                                push @users, $CONTACTS->{$contact}->{cn};
                            }
                        }
                    }
                }
            } else {
                DebugOutput("GENERATE HOSTCONFIG 2x", "Skipping $CLIENTS->{$client}->{cn} notification, no contactgroups found.");
            }

            if (defined($CLIENTS->{$client}->{$cfg->{ldap}->{prefix}.'hostcontacts'})) {
                my @contacts = split /,/, $CLIENTS->{$client}->{$cfg->{ldap}->{prefix}.'hostcontacts'};
                push @users, @contacts;
            } else {

                #DebugOutput("GENERATE HOSTCONFIG 2x", "Skipping $CLIENTS->{$client}->{cn} notification, no contacts found.");
            }

            if (@users) {

                # make sure that group members and contacts remain unique
                @users = uniq(@users);

                #DebugOutput("GENERATE HOSTCONFIG 2x", Dumper(@users));
            }

            my $user_cnt = 0;

            # now that we've got all users, get their notification commands
            foreach my $user (@users) {
                my $notification_cnt = 0;

                #DebugOutput("GENERATE HOSTCONFIG 2x", "Looking for user $user in ".Dumper($CONTACTS));

                foreach my $contact (keys %{$CONTACTS}) {

                    #DebugOutput("GENERATE HOSTCONFIG 2x", "Looking for user $user in ".Dumper($CONTACTS->{$contact}));

                    if ($CONTACTS->{$contact}->{cn} eq $user) {
                        DebugOutput("GENERATE HOSTCONFIG 2x", "Building notification for host '$CLIENTS->{$client}->{cn}' and user '$user'");

                        my $default_notification_command = undef;
                        # build the notification based on the commands
                        my @host_notification_commands = ();
                        if (defined($CONTACTS->{$contact}->{$cfg->{ldap}->{prefix}.'contacthostnotificationcommands'})) {
                            @host_notification_commands = split /,/, $CONTACTS->{$contact}->{$cfg->{ldap}->{prefix}.'contacthostnotificationcommands'};
                        } else {
                            my $msg = "Can not build notification for host '$CLIENTS->{$client}->{cn}' and contact '$user', please define a contact host notification command!";
                            beVerbose("GENERATE HOSTCONFIG 2x", $msg);
                            DebugOutput("GENERATE HOSTCONFIG 2x", $msg);

                            # FIXME Should we use the default mail notification command?
                            $default_notification_command = "mail-host-notification";
                            push @host_notification_commands, $default_notification_command;
                            $msg = "ATTENTION: Using the default NotificationCommand '$default_notification_command' for the notification on host '$CLIENTS->{$client}->{cn}'!";
                            beVerbose("GENERATE HOSTCONFIG 2x", $msg);
                            DebugOutput("GENERATE HOSTCONFIG 2x", $msg);
                        }

                        foreach my $notification_command_name (@host_notification_commands) {
                            my $notification_name = "host-".$CLIENTS->{$client}->{cn}."-".$notification_command_name."-".$notification_cnt."-".$user_cnt;

                            my $notification_command_object_name = "notification-".$notification_name; # generate a unique command name for this notification

                            print FH "object Notification \"$notification_name\" {\n";
                            print FH "\timport \"mail-host-notification\"\n";

                            print FH "\thost_name = \"$CLIENTS->{$client}->{cn}\"\n";

                            # get the command line, add a new notification command
                            my $notification_command_line = undef; # we don't have args for notification commands
                            foreach my $command (keys %{$COMMANDS}) {
                                if ($COMMANDS->{$command}->{cn} eq $notification_command_name) {
                                    $notification_command_line = $COMMANDS->{$command}->{$cfg->{ldap}->{prefix}.'commandline'};
                                    last;
                                }
                            }

                            # if the command line was found, we assume to create a new notification command.
                            # if not, the user supplied an external notification command (e.g. defined in default-templates.conf)
                            # we don't care about that but will log a warning while setting the attribute
                            if (defined($notification_command_line)) {
                                # 2016-07-18, MF: just reference the original notification command, we'll generate it anyways using genCommands2x with type 'Notification'
                                # This avoids duplicated notification command definitions
                                print FH "\tcommand = \"$notification_command_name\"\n";
                                #$notification_commands->{$notification_command_object_name} = $notification_command_line;
                                # notification command
                                #print FH "\tcommand = \"$notification_command_object_name\"\n";
                            } else {
                                $msg = "WARNING: Using the external NotificationCommand '$notification_command_name' for host '$CLIENTS->{$client}->{cn}' for notifications!";

                                beVerbose("GENERATE HOSTCONFIG 2x", $msg);
                                DebugOutput("GENERATE HOSTCONFIG 2x", $msg);

                                # notification command
                                print FH "\tcommand = \"$notification_command_name\"\n";
                            }

                            # notification options
                            if (defined($CLIENTS->{$client}->{$cfg->{ldap}->{prefix}.'hostnotificationoptions'})) {
                                my $notification_filters = convert_notification_options_to_filter_2x($CLIENTS->{$client}->{$cfg->{ldap}->{prefix}.'hostnotificationoptions'}, 1);

                                foreach my $by (keys %{$notification_filters}) {
                                    next if !@{$notification_filters->{$by}};
                                    my $notification_filter;
                                    if (grep /0/, @{$notification_filters->{$by}}) {
                                        $notification_filter = 0;
                                    } else {
                                        $notification_filter = "[ ". (join ', ', @{$notification_filters->{$by}}) ." ]";
                                    }
                                    print FH "\t".$by."s = $notification_filter\n";
                                }
                            }

                            # notification period
                            if (defined($CLIENTS->{$client}->{$cfg->{ldap}->{prefix}.'hostnotificationperiod'})) {
                                print FH "\tperiod = \"$CLIENTS->{$client}->{$cfg->{ldap}->{prefix}.'hostnotificationperiod'}\"\n";
                            }

                            # notification interval
                            if (defined($CLIENTS->{$client}->{$cfg->{ldap}->{prefix}.'hostnotificationinterval'})) {
                                print FH "\tinterval = ".convert_interval_2x($CLIENTS->{$client}->{$cfg->{ldap}->{prefix}.'hostnotificationinterval'})."\n";
                            }

                            # notification delay
                            if (defined($CLIENTS->{$client}->{$cfg->{ldap}->{prefix}.'hostfirstnotificationdelay'})) {
                                print FH "\ttimes.begin = ".convert_interval_2x($CLIENTS->{$client}->{$cfg->{ldap}->{prefix}.'hostfirstnotificationdelay'})."\n";
                            }

                            print FH "\tusers = [ \"$user\" ]\n";

                            print FH "}\n";
                            print FH "\n";

                            # next notification command
                            $notification_cnt++;
                        }

                        # next notification contact
                        $notification_cnt++;
                    }
                    $user_cnt++;
                }
            }

            #
            # service escalations as notification with begin/end
            #

            if (defined $CLIENTS->{$client}->{HOSTESCALATION}) {
                foreach my $escalation (sort keys %{$CLIENTS->{$client}->{HOSTESCALATION}}) {

                    my $host_escalation_firstnotification = $CLIENTS->{$client}->{HOSTESCALATION}->{$escalation}->{$cfg->{ldap}->{prefix}.'hostescalationfirstnotification'};
                    my $host_escalation_lastnotification = $CLIENTS->{$client}->{HOSTESCALATION}->{$escalation}->{$cfg->{ldap}->{prefix}.'hostescalationlastnotification'};
                    my $host_escalation_notificationinterval = $CLIENTS->{$client}->{HOSTESCALATION}->{$escalation}->{$cfg->{ldap}->{prefix}.'hostescalationnotificationinterval'};
                    my $host_escalation_contacts = $CLIENTS->{$client}->{HOSTESCALATION}->{$escalation}->{$cfg->{ldap}->{prefix}.'hostescalationcontacts'};
                    my $host_escalation_contactgroups = $CLIENTS->{$client}->{HOSTESCALATION}->{$escalation}->{$cfg->{ldap}->{prefix}.'hostescalationcontactgroups'};

                    my $begin;
                    my $end;

                    print FH "object Notification \"$escalation\" {\n";
                    print FH "\timport \"mail-host-notification\"\n";

                    # if missing, set a default of 5m
                    if (!defined($host_escalation_notificationinterval)) {
                        $host_escalation_notificationinterval = 5;
                    }

                    print FH "\ttimes = {\n";

                    if (defined($host_escalation_firstnotification)) {
                        $begin = $host_escalation_firstnotification * $host_escalation_notificationinterval;
                        print FH "\t\tbegin = ".convert_interval_2x($begin).",\n";
                    }

                    if (defined($service_escalation_lastnotification)) {
                        $end = $host_escalation_lastnotification * $host_escalation_notificationinterval;
                        print FH "\t\tend = ".convert_interval_2x($end).",\n";
                    }

                    print FH "\t}\n";

                    if (defined($host_escalation_contacts)) {
                        my @users = split /,/, $host_escalation_contacts;
                        print FH "\tusers = [ \"".join("\", \"", @users)."\" ],\n";
                    }
                    if (defined($host_escalation_contactgroups)) {
                        my @usergroups = split /,/, $host_escalation_contactgroups;
                        print FH "\tuser_groups = [ \"".join("\", \"", @usergroups)."\" ],\n";
                    }

                    print FH "}\n";
                    print FH "\n";

                }
            }

            #
            # SERVICES
            #
            foreach my $service (keys %{$CLIENTS->{$client}->{'SERVICES'}}) {

                DebugOutput("GENERATE HOSTCONFIG 2x", "Found service $service", 1);

                # only gen service if lconfservicedisable is not set
                if (!defined $CLIENTS->{$client}->{'SERVICES'}->{$service}->{"$cfg->{ldap}->{prefix}servicedisable"}) {
                    print FH "object Service \"$CLIENTS->{$client}->{'SERVICES'}->{$service}->{cn}\" {\n";
                    print FH "\timport \"generic-service\"\n";

                    print FH "\thost_name = \"$CLIENTS->{$client}->{cn}\"\n";

                    # initialize each service macro / custom dict
                    my $vars_svc = ();

                    #
                    # ordinary service attributes
                    #

                    # process each item
                    foreach my $val1 (sort keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}}) {

                        # ...but look after type; only service items!

                        #
                        # default service attributes
                        #

                        # check command with macro arguments
                        if ($val1 eq "$cfg->{ldap}->{prefix}servicecheckcommand" || $val1 eq "$cfg->{ldap}->{prefix}checkcommand") {
                            my ($checkcommand_name, @checkcommand_macros) = split /!/, "$CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}";

                            my $arg_c = 1;
                            foreach my $macro_val (@checkcommand_macros) {

                                # check command arg name for being an icinga 1.x macro and resolve its value
                                if ($macro_val =~ /^\$(\w+)\$$/) {
                                    if ($1 =~ /^_HOST(\w+)/) {
                                        my $cv_val_macro_key = "_".$1;

                                        # override the original cv value with the resolved host cv
                                        $macro_val = $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostcustomvar"}->{$cv_val_macro_key};
                                    }
                                    elsif ($1 =~ /^_SERVICE(\w+)/) {
                                        my $cv_val_macro_key = "_".$1;

                                        # override the original cv value with the resolved service cv
                                        $macro_val = $CLIENTS->{$client}->{'SERVICES'}->{$service}->{"$cfg->{ldap}->{prefix}servicecustomvar"}->{$cv_val_macro_key};
                                    }
                                }

                                $vars_svc->{'ARG'.$arg_c} = escape_str($macro_val);

                                $arg_c++;
                            }

                            print FH "\tcheck_command = \"$checkcommand_name\"\n";

                        }
                        elsif ($val1 eq "$cfg->{ldap}->{prefix}serviceactionurl" ||
                            $val1 eq "$cfg->{ldap}->{prefix}servicenotesurl" ||
                            $val1 eq "$cfg->{ldap}->{prefix}servicenotes" ||
                            $val1 eq "$cfg->{ldap}->{prefix}iconimage" ||
                            $val1 eq "$cfg->{ldap}->{prefix}iconimagealt"
                          ) {
                            print FH "\t\t$itemMapIcinga2{$val1} = \"$CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}\"\n";
                        } elsif ($val1 eq "$cfg->{ldap}->{prefix}servicegroups") {
                            my @groups = split(',', $CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1});
                            my $groups = join ",", grep length, @groups;
                            $groups =~ s/,/\", \"/g;
                            print FH "\tgroups = [ \"$groups\" ]\n";
                        } elsif ($val1 eq "$cfg->{ldap}->{prefix}servicedisplayname") {
                            print FH "\tdisplay_name = \"$CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}\"\n";
                        } elsif ($val1 eq "$cfg->{ldap}->{prefix}servicecheckperiod") {
                            print FH "\tcheck_period = \"$CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}\"\n";
                        } elsif ($val1 eq "$cfg->{ldap}->{prefix}servicecheckinterval") {
                            print FH "\tcheck_interval = ".convert_interval_2x($CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1})."\n";
                        } elsif ($val1 eq "$cfg->{ldap}->{prefix}servicecheckretryinterval") {
                            print FH "\tretry_interval = ".convert_interval_2x($CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1})."\n";
                        } elsif ($val1 eq "$cfg->{ldap}->{prefix}servicecheckmaxcheckattempts") {
                            print FH "\tmax_check_attempts = $CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}\n";
                        } elsif ($val1 eq "$cfg->{ldap}->{prefix}servicecustomvar") {
                            foreach my $val2 (sort keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}}) {
                                next if (!defined($val2) ||
                                        $val2 eq "" ||
                                        $val2 eq "_" ||
                                        !defined($CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}->{$val2}) ||
                                        $CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}->{$val2} eq "");
                                $key = $val2;
                                $key =~ s/_//;
                                $vars_svc->{$key} = escape_str($CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}->{$val2});
                            }
                        } elsif ($val1 eq "$cfg->{ldap}->{prefix}serviceactivechecksenabled") {
                            print FH "\tenable_active_checks = $CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}\n";
                        } elsif ($val1 eq "$cfg->{ldap}->{prefix}servicepassivechecksenabled") {
                            print FH "\tenable_passive_checks = $CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}\n";
                        } elsif ($val1 eq "$cfg->{ldap}->{prefix}serviceprocessperfdata") {
                            print FH "\tenable_perfdata = $CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}\n";
                        } elsif ($val1 eq "$cfg->{ldap}->{prefix}servicenotificationsenabled") {
                            print FH "\tenable_notifications = $CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}\n";
                        } elsif ($val1 eq "$cfg->{ldap}->{prefix}serviceflapdetectionenabled") {
                            print FH "\tenable_flapping = $CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}\n";
                        } elsif ($val1 eq "$cfg->{ldap}->{prefix}serviceeventhandler") {

                            my ($event_command_name, @event_command_macros) = split /!/, "$CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}";

                            my $event_arg_c = 1;
                            foreach my $macro_val (@event_command_macros) {

                                # check command arg name for being an icinga 1.x macro and resolve its value
                                if ($macro_val =~ /^\$(\w+)\$$/) {
                                    if ($1 =~ /^_HOST(\w+)/) {
                                        my $cv_val_macro_key = "_".$1;

                                        # override the original cv value with the resolved host cv
                                        $macro_val = $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostcustomvar"}->{$cv_val_macro_key};
                                    }
                                    elsif ($1 =~ /^_SERVICE(\w+)/) {
                                        my $cv_val_macro_key = "_".$1;

                                        # override the original cv value with the resolved service cv
                                        $macro_val = $CLIENTS->{$client}->{'SERVICES'}->{$service}->{"$cfg->{ldap}->{prefix}servicecustomvar"}->{$cv_val_macro_key};
                                    }
                                }

                                $vars_svc->{'EVENTARG'.$event_arg_c} = escape_str($macro_val); # special prefix 'EVENTARG' for eventhandler arguments

                                $event_arg_c++;
                            }

                            my $event_command_object_name = "host-$CLIENTS->{$client}->{cn}-service-$service-$event_command_name";

                            my $event_command_line;
                            foreach my $command (keys %{$COMMANDS}) {
                                if ($COMMANDS->{$command}->{cn} eq $event_command_name) {
                                    $event_command_line = escape_str($COMMANDS->{$command}->{$cfg->{ldap}->{prefix}.'commandline'});

                                    $event_command_line =~ s/ARG/EVENTARG/g; # required for eventhandler arguments

                                    goto FOUND_EVENT;
                                }
                            }

                            FOUND_EVENT:

                            $event_commands->{$event_command_object_name} = $event_command_line;

                            print FH "\tevent_command = \"$event_command_object_name\"\n";
                        }
                    }

                    foreach my $var (sort keys %{$vars_svc}) {
                        print FH "\tvars.$var = \"$vars_svc->{$var}\"\n";
                    }

                    print FH "}\n";
                    print FH "\n";

                    #
                    # service dependencies
                    #
                    if (defined $CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEDEPENDENCY}) {
                        foreach my $dependency (sort keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEDEPENDENCY}}) {
                            my ($depHost, $depService) = (split(/ *-> */, $dependency))[0,1];

                            print FH "object Dependency \"$depHost-$depService\" {\n";

                            # special stuff for inheritance
                            if ($depHost eq "\$HOSTNAME\$") {
                                $depHost = $CLIENTS->{$client}->{cn};
                            }

                            print FH "\tparent_host_name = \"$depHost\"\n";
                            print FH "\tparent_service_name = \"$depService\"\n";
                            print FH "\tchild_host_name = \"$CLIENTS->{$client}->{cn}\"\n";
                            print FH "\tchild_service_name = \"$service\"\n";

                            foreach (sort keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEDEPENDENCY}->{$dependency}}) {
                                if ($_ eq "$cfg->{ldap}->{prefix}servicedependencyexecutionfailurecriteria") {
                                    my $fail_crit = convert_dependendy_failure_criteria_2x($CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEDEPENDENCY}->{$dependency}->{$_}, 'check', 0);
                                    DebugOutput("GENERATE HOSTCONFIG 2x", "SERVICEDEPENDENCY: exec: $CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEDEPENDENCY}->{$dependency}->{$_}: ".Dumper($fail_crit));
                                    print FH "\tdisable_checks = true\n" if $fail_crit->{'runeverything'} == 0;
                                    print FH "\tdisable_checks = false\n" if $fail_crit->{'runeverything'} == 1;
                                    print FH "\tstates = [ ". (join ', ', @{$fail_crit->{'state'}}) ." ]\n"; # execution failure criteria is mandatory for state_filter
                                }
                                if ($_ eq "$cfg->{ldap}->{prefix}servicedependencynotificationfailurecriteria") {
                                    my $fail_crit = convert_dependendy_failure_criteria_2x($CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEDEPENDENCY}->{$dependency}->{$_}, 'notification', 0);
                                    DebugOutput("GENERATE HOSTCONFIG 2x", "SERVICEDEPENDENCY: notif: $CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEDEPENDENCY}->{$dependency}->{$_}: ".Dumper($fail_crit));
                                    print FH "\tdisable_notifications = true\n" if $fail_crit->{'runeverything'} == 0;
                                    print FH "\tdisable_notifications = false\n" if $fail_crit->{'runeverything'} == 1;
                                }
                            }
                            print FH "}\n";
                        }
                    }

                    #
                    # service notifications
                    #

                    # parse contacts, contactgroups
                    my @users = ();
                    if (defined($CLIENTS->{$client}->{'SERVICES'}->{$service}->{$cfg->{ldap}->{prefix}.'servicecontactgroups'})) {
                        # fancy, we've got multiple contactgroups as well
                        my $groups_str = $CLIENTS->{$client}->{'SERVICES'}->{$service}->{$cfg->{ldap}->{prefix}.'servicecontactgroups'};
                        DebugOutput("GENERATE HOSTCONFIG 2x", "Migrating contactgroups: '$groups_str' from service '$service'.");
                        my @groups = str2arr_by_delim_without_excludes($groups_str, ',', 0);

                        # fetch all members from all contactgroups
                        foreach my $group (@groups) {

                            # STAGE 1: get all contactgroup members which are matching
                            foreach my $contactgroup (keys %{$CONTACTGROUPS}) {
                                DebugOutput("GENERATE HOSTCONFIG 2x", "Generating Notifications, STAGE 1: Looking for contactgroup '$CONTACTGROUPS->{$contactgroup}->{cn}' members attribute.");

                                #DebugOutput("GENERATE HOSTCONFIG 2x", Dumper($CONTACTGROUPS->{$contactgroup}));
                                if ($CONTACTGROUPS->{$contactgroup}->{cn} eq $group) {
                                    if (defined($CONTACTGROUPS->{$contactgroup}->{$cfg->{ldap}->{prefix}.'members'})) {
                                        my @members = split /,/, $CONTACTGROUPS->{$contactgroup}->{$cfg->{ldap}->{prefix}.'members'};
                                        push @users, @members;
                                    }
                                }
                            }

                            # STAGE 2: loop over all contacts and compare if their groups match the requested one
                            foreach my $contact (keys %{$CONTACTS}) {
                                DebugOutput("GENERATE HOSTCONFIG 2x", "Generating Notifications, STAGE 2: Looking for contacts '$CONTACTS->{$contact}->{cn}' attribute contactgroups matching the current contactgroup '$group'.");
                                if (defined($CONTACTS->{$contact}->{$cfg->{ldap}->{prefix}.'contactgroups'})) {
                                    DebugOutput("GENERATE HOSTCONFIG 2x", "contactgroups attribute found: '$CONTACTS->{$contact}->{$cfg->{ldap}->{prefix}.'contactgroups'}'. Matches '$group'?.");

                                    # this is ugly, find a better match condition
                                    if ($CONTACTS->{$contact}->{$cfg->{ldap}->{prefix}.'contactgroups'} =~ /$group/) {
                                        push @users, $CONTACTS->{$contact}->{cn};
                                    }
                                }
                            }
                        }
                    } else {
                        DebugOutput("GENERATE HOSTCONFIG 2x", "Skipping $service notification, no contactgroups found.");
                    }

                    if (defined($CLIENTS->{$client}->{'SERVICES'}->{$service}->{$cfg->{ldap}->{prefix}.'servicecontacts'})) {
                        my @contacts = split /,/, $CLIENTS->{$client}->{'SERVICES'}->{$service}->{$cfg->{ldap}->{prefix}.'servicecontacts'};
                        push @users, @contacts;
                    } else {

                        #DebugOutput("GENERATE HOSTCONFIG 2x", "Skipping $service notification, no contacts found.");
                    }

                    if (@users) {

                        # make sure that group members and contacts remain unique
                        @users = uniq(@users);

                        #DebugOutput("GENERATE HOSTCONFIG 2x", Dumper(@users));
                    }

                    my $user_cnt = 0;

                    # now that we've got all users, get their notification commands
                    foreach my $user (@users) {
                        my $notification_cnt = 0;

                        #DebugOutput("GENERATE HOSTCONFIG 2x", "Looking for user $user in ".Dumper($CONTACTS));

                        foreach my $contact (keys %{$CONTACTS}) {

                            #DebugOutput("GENERATE HOSTCONFIG 2x", "Looking for user $user in ".Dumper($CONTACTS->{$contact}));

                            if ($CONTACTS->{$contact}->{cn} eq $user) {
                                DebugOutput("GENERATE HOSTCONFIG 2x", "Building notification for service '$service' and user '$user'");

                                my $default_notification_command = undef;
                                # build the notification based on the commands
                                my @service_notification_commands = ();
                                if (defined($CONTACTS->{$contact}->{$cfg->{ldap}->{prefix}.'contactservicenotificationcommands'})) {
                                    @service_notification_commands = split /,/, $CONTACTS->{$contact}->{$cfg->{ldap}->{prefix}.'contactservicenotificationcommands'};
                                } else {
                                    my $msg = "Can not build notification for service '$service' on host '$CLIENTS->{$client}->{cn}' and contact '$user', please define a contact service notification command!";

                                    beVerbose("GENERATE HOSTCONFIG 2x", $msg);
                                    DebugOutput("GENERATE HOSTCONFIG 2x", $msg);

                                    # FIXME Should we use the default mail notification command?
                                    $default_notification_command = "mail-service-notification";
                                    push @service_notification_commands, $default_notification_command;

                                    $msg = "ATTENTION: Using the default NotificationCommand '$default_notification_command' for service '$service' on host '$CLIENTS->{$client}->{cn}' for notifications!";

                                    beVerbose("GENERATE HOSTCONFIG 2x", $msg);
                                    DebugOutput("GENERATE HOSTCONFIG 2x", $msg);
                                }

                                foreach my $notification_command_name (@service_notification_commands) {
                                    my $notification_name = "host-".$CLIENTS->{$client}->{cn}."-service-".$CLIENTS->{$client}->{'SERVICES'}->{$service}->{cn}."-".$notification_command_name."-".$notification_cnt."-".$user_cnt;

                                    my $notification_command_object_name = "notification-".$notification_name; # generate a unique command name for this notification

                                    print FH "object Notification \"$notification_name\" {\n";
                                    print FH "\timport \"mail-service-notification\"\n";

                                    print FH "\thost_name = \"$CLIENTS->{$client}->{cn}\"\n";
                                    print FH "\tservice_name = \"$CLIENTS->{$client}->{'SERVICES'}->{$service}->{cn}\"\n";

                                    # get the command line, add a new notification command
                                    my $notification_command_line = undef; # we don't have args for notification commands
                                    foreach my $command (keys %{$COMMANDS}) {
                                        if ($COMMANDS->{$command}->{cn} eq $notification_command_name) {
                                            $notification_command_line = $COMMANDS->{$command}->{$cfg->{ldap}->{prefix}.'commandline'};
                                            last;
                                        }
                                    }

                                    # if the command line was found, we assume to create a new notification command.
                                    # if not, the user supplied an external notification command (e.g. defined in default-templates.conf)
                                    # we don't care about that but will log a warning while setting the attribute
                                    if (defined($notification_command_line)) {
                                       # 2016-07-18, MF: just reference the original notification command, we'll generate it anyways using genCommands2x with type 'Notification'
                                       # This avoids duplicated notification command definitions
                                       print FH "\tcommand = \"$notification_command_name\"\n";
                                        #$notification_commands->{$notification_command_object_name} = $notification_command_line;
                                        # notification command
                                        #print FH "\tcommand = \"$notification_command_object_name\"\n";
                                    } else {
                                        $msg = "WARNING: Using the external NotificationCommand '$notification_command_name' for service '$service' on host '$CLIENTS->{$client}->{cn}' for notifications!";

                                        beVerbose("GENERATE HOSTCONFIG 2x", $msg);
                                        DebugOutput("GENERATE HOSTCONFIG 2x", $msg);

                                        # notification command
                                        print FH "\tcommand = \"$notification_command_name\"\n";
                                    }

                                    # notification options
                                    if (defined($CLIENTS->{$client}->{'SERVICES'}->{$service}->{$cfg->{ldap}->{prefix}.'servicenotificationoptions'})) {
                                        my $notification_filters = convert_notification_options_to_filter_2x($CLIENTS->{$client}->{'SERVICES'}->{$service}->{$cfg->{ldap}->{prefix}.'servicenotificationoptions'}, 0);

                                        foreach my $by (keys %{$notification_filters}) {
                                            next if !@{$notification_filters->{$by}};
                                            my $notification_filter;
                                            if (grep /0/, @{$notification_filters->{$by}}) {
                                                $notification_filter = 0;
                                            } else {
                                                $notification_filter = "[ ". (join ', ', @{$notification_filters->{$by}}) ." ]";
                                            }
                                            print FH "\t".$by."s = $notification_filter\n";
                                        }
                                    }

                                    # notification period
                                    if (defined($CLIENTS->{$client}->{'SERVICES'}->{$service}->{$cfg->{ldap}->{prefix}.'servicenotificationperiod'})) {
                                        print FH "\tperiod = \"$CLIENTS->{$client}->{'SERVICES'}->{$service}->{$cfg->{ldap}->{prefix}.'servicenotificationperiod'}\"\n";
                                    }

                                    # notification interval
                                    if (defined($CLIENTS->{$client}->{'SERVICES'}->{$service}->{$cfg->{ldap}->{prefix}.'servicenotificationinterval'})) {
                                        print FH "\tinterval = ".convert_interval_2x($CLIENTS->{$client}->{'SERVICES'}->{$service}->{$cfg->{ldap}->{prefix}.'servicenotificationinterval'})."\n";
                                    }

                                    # notification delay
                                    if (defined($CLIENTS->{$client}->{'SERVICES'}->{$service}->{$cfg->{ldap}->{prefix}.'servicefirstnotificationdelay'})) {
                                        print FH "\ttimes.begin = ".convert_interval_2x($CLIENTS->{$client}->{'SERVICES'}->{$service}->{$cfg->{ldap}->{prefix}.'servicefirstnotificationdelay'})."\n";
                                    }

                                    print FH "\tusers = [ \"$user\" ]\n";

                                    print FH "}\n";
                                    print FH "\n";

                                    # next notification command
                                    $notification_cnt++;
                                }

                                # next notification contact
                                $notification_cnt++;
                            }
                            $user_cnt++;
                        }
                    }

                    #
                    # service escalations as notification with begin/end
                    #

                    if (defined $CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEESCALATION}) {
                        foreach my $escalation (sort keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEESCALATION}}) {

                            my $service_escalation_firstnotification = $CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEESCALATION}->{$escalation}->{$cfg->{ldap}->{prefix}.'serviceescalationfirstnotification'};
                            my $service_escalation_lastnotification = $CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEESCALATION}->{$escalation}->{$cfg->{ldap}->{prefix}.'serviceescalationlastnotification'};
                            my $service_escalation_notificationinterval = $CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEESCALATION}->{$escalation}->{$cfg->{ldap}->{prefix}.'serviceescalationnotificationinterval'};
                            my $service_escalation_contacts = $CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEESCALATION}->{$escalation}->{$cfg->{ldap}->{prefix}.'serviceescalationcontacts'};
                            my $service_escalation_contactgroups = $CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEESCALATION}->{$escalation}->{$cfg->{ldap}->{prefix}.'serviceescalationcontactgroups'};

                            my $begin;
                            my $end;

                            print FH "object Notification \"$escalation\" {\n";
                            print FH "\timport \"mail-service-notification\"\n";

                            # if missing, set a default of 5m
                            if (!defined($service_escalation_notificationinterval)) {
                                $service_escalation_notificationinterval = 5;
                            }

                            print FH "\ttimes = {\n";

                            if (defined($service_escalation_firstnotification)) {
                                $begin = $service_escalation_firstnotification * $service_escalation_notificationinterval;
                                print FH "\t\tbegin = ".convert_interval_2x($begin).",\n";
                            }

                            if (defined($service_escalation_lastnotification)) {
                                $end = $service_escalation_lastnotification * $service_escalation_notificationinterval;
                                print FH "\t\tend = ".convert_interval_2x($end).",\n";
                            }

                            print FH "\t}\n";

                            if (defined($service_escalation_contacts)) {
                                my @users = split /,/, $service_escalation_contacts;
                                print FH "\tusers = [ \"".join("\", \"", @users)."\" ]\n";
                            }
                            if (defined($service_escalation_contactgroups)) {
                                my @usergroups = split /,/, $service_escalation_contactgroups;
                                print FH "\tuser_groups = [ \"".join("\", \"", @usergroups)."\" ]\n";
                            }

                            print FH "}\n";
                            print FH "\n";

                        }
                    }
                } else {
                    DebugOutput("GENERATE HOSTCONFIG 2x", "Skipping disabled service '$service' ", 1);
                }

            }

            print FH "\n";

            foreach my $event_command_object_name (keys %{$event_commands}) {
                print FH "object EventCommand \"$event_command_object_name\" {\n";
                print FH "\timport \"generic-event-command\"\n";
                my $command_line = $event_commands->{$event_command_object_name};

                # 1.x definition
                if ($command_line =~ /\$(USER\d+)\$/) {
                    $command_line = "\"".escape_str($command_line)."\""; # escape quotes
                }
                if ($command_line !~ /^"/) {
                    $command_line = "\"".escape_str($command_line)."\""; # escape quotes
                }
                print FH "\tcommand = $command_line\n";
                print FH "}\n";
                print FH "\n";
            }

        } else {
            DebugOutput("GENERATE HOSTCONFIG 2x", "Skipping disabled host '$client' ", 1);
        }
    }
}

1;

# vi: sw=4 ts=4 expandtab :
