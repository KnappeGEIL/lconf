# COPYRIGHT:
#
# This software is Copyright (c) 2010 - 2013 NETWAYS GmbH
#                                <support@netways.de>
#
# (Except where explicitly superseded by other copyright notices)
#
#
# LICENSE:
#
# This work is made available to you under the terms of Version 2 of
# the GNU General Public License. A copy of that license should have
# been provided with this software, but in any event can be snarfed
# from http://www.fsf.org.
#
# This work is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301 or visit their web page on the internet at
# http://www.fsf.org.
#
#
# CONTRIBUTION SUBMISSION POLICY:
#
# (The following paragraph is not intended to limit the rights granted
# to you to modify and distribute this software under the terms of
# the GNU General Public License and is only of importance to you if
# you choose to contribute your changes and enhancements to the
# community by submitting them to NETWAYS GmbH.)
#
# By intentionally submitting any modifications, corrections or
# derivatives to this work, or any other work intended for use with
# this Software, to NETWAYS GmbH, you confirm that
# you are the copyright holder for those contributions and you grant
# NETWAYS GmbH a nonexclusive, worldwide, irrevocable,
# royalty-free, perpetual, license to use, copy, create derivative
# works based on those contributions, and sublicense and distribute
# those contributions and any derivatives thereof.
#
# Nagios and the Nagios logo are registered trademarks of Ethan Galstad.

#
# TIMEPERIODS
#
sub genTimeperiods {
    my $CONFIG = shift;
    my $target = shift;
    my $dir    = shift;
    my $format = shift;
    my $outputDir;

    # set output dir
    if (defined $dir) { $outputDir = $dir; } else { $outputDir = $opt->{outputDir}; }

    # get all timeperiods
    my $TIMEPERIODS = HashGrep($CONFIG, 'objectclass', $cfg->{ldap}->{prefix}.'Timeperiod');

    # check all timeperiods... are they below $cfg->{ldap}->{baseDN} ?
    # --> so timeperiod objects in ou=Examples and ou=Templates will not be handled
    foreach my $val (keys %{$TIMEPERIODS}) { delete $TIMEPERIODS->{$val} if $val !~ /$cfg->{ldap}->{baseDN}$/; }

    # a special target is set?
    if (defined($target)) { foreach my $val (keys %{$TIMEPERIODS}) { delete $TIMEPERIODS->{$val} if $val !~ /$target$/; } }

    if (defined $cfg->{export}->{format} && $cfg->{export}->{format} == 2) {
        genTimeperiods2x($TIMEPERIODS, $outputDir);
    } else {
        genTimeperiods1x($TIMEPERIODS, $outputDir);
    }
}

sub genTimeperiods1x {
    my $TIMEPERIODS = shift;
    my $outputDir = shift;

    foreach my $timeperiod (keys %{$TIMEPERIODS}) {
        # get target file's name and open it for writing
        my $writeFile = BuildFilepath($TIMEPERIODS->{$timeperiod}->{dn}, $outputDir);
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

        print FH "define timeperiod {\n";
        foreach (sort keys %{$TIMEPERIODS->{$timeperiod}}) {
            if ($itemMap{$_} || $_ eq "$cfg->{ldap}->{prefix}timeperiodvalue") {
                if ($_ eq 'cn') {
                    print FH "\ttimeperiod_name\t$TIMEPERIODS->{$timeperiod}->{$_}\n";
                } elsif ($_ eq "$cfg->{ldap}->{prefix}timeperiodvalue") {
                    foreach my $val (sort keys %{$TIMEPERIODS->{$timeperiod}->{$_}}) {
                        foreach my $timeperiod_value (sort keys %{$TIMEPERIODS->{$timeperiod}->{$_}->{$val}}) {
                            my $key = $timeperiod_value;
                            $key =~ s/^\s+//;
                            $key =~ s/^\t//;
                            $key =~ s/\s+$//;
                            $key =~ s/\t$//;
                            print FH "\t$key\t$TIMEPERIODS->{$timeperiod}->{$_}->{$val}->{$timeperiod_value}\n";
                        }
                    }
                } else {
                    print FH "\t$itemMap{$_}\t$TIMEPERIODS->{$timeperiod}->{$_}\n";
                }
            }
        }
        print FH "}\n";

        # close target file
        close(FH);
    }
}

sub genTimeperiods2x {
    my $TIMEPERIODS = shift;
    my $outputDir = shift;

    foreach my $timeperiod (keys %{$TIMEPERIODS}) {
        # get target file's name and open it for writing
        my $writeFile = BuildFilepath($TIMEPERIODS->{$timeperiod}->{dn}, $outputDir);
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

        print FH "object TimePeriod \"$TIMEPERIODS->{$timeperiod}->{cn}\"{\n";
        print FH "\timport \"legacy-timeperiod\"\n";
        print FH "\tranges = {\n";
        foreach (sort keys %{$TIMEPERIODS->{$timeperiod}}) {
            if ($_ eq "$cfg->{ldap}->{prefix}timeperiodvalue") {
                foreach my $val (sort keys %{$TIMEPERIODS->{$timeperiod}->{$_}}) {
                    foreach my $timeperiod_value (sort keys %{$TIMEPERIODS->{$timeperiod}->{$_}->{$val}}) {
                        my $key = $timeperiod_value;
                        $key =~ s/^\s+//;
                        $key =~ s/^\t//;
                        $key =~ s/\s+$//;
                        $key =~ s/\t$//;
                        print FH "\t\t\"$key\" = \"$TIMEPERIODS->{$timeperiod}->{$_}->{$val}->{$timeperiod_value}\"\n";
                    }
                }
            }
        }
        print FH "\t}\n";
        print FH "}\n";

        # close target file
        close(FH);
    }
}

#
# COMMANDS
#
sub genCommands {
    my $CONFIG = shift;
    my $target = shift;
    my $dir    = shift;
    my $outputDir;

    # set output dir
    if (defined $dir) { $outputDir = $dir; } else { $outputDir = $opt->{outputDir}; }

    # get all commands
    my $COMMANDS = HashGrep($CONFIG, 'objectclass', $cfg->{ldap}->{prefix}.'Command');

    # check all commands... are they below $cfg->{ldap}->{baseDN} ?
    # --> so command objects in ou=Examples and ou=Templates will not be handled
    foreach my $val (keys %{$COMMANDS}) { delete $COMMANDS->{$val} if $val !~ /$cfg->{ldap}->{baseDN}$/; }

    # a special target is set?
    if (defined($target)) { foreach my $val (keys %{$COMMANDS}) { delete $COMMANDS->{$val} if $val !~ /$target$/; } }

    if (defined $cfg->{export}->{format} && $cfg->{export}->{format} == 2) {
        genCommands2x($COMMANDS, $outputDir);
    } else {
        genCommands1x($COMMANDS, $outputDir);
    }
}

sub genCommands1x {
    my $COMMANDS = shift;
    my $outputDir = shift;

    foreach my $command (keys %{$COMMANDS}) {
        # get target file's name and open it for writing
        my $writeFile = BuildFilepath($COMMANDS->{$command}->{dn}, $outputDir);
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

        print FH "define command {\n";
        foreach (sort keys %{$COMMANDS->{$command}}) {
            if ($itemMap{$_}) {
                if ($_ eq 'cn') {
                    print FH "\tcommand_name\t $COMMANDS->{$command}->{$_}\n";
                } else {
                    print FH "\t$itemMap{$_}\t $COMMANDS->{$command}->{$_}\n";
                }
            }
        }
        print FH "}\n";

        # close target file
        close(FH);
    }
}

sub genCommands2x {
    my $COMMANDS = shift;
    my $outputDir = shift;
    my $type = 'Check'; #FIXME for notifications/events
    my $template = "plugin-check-command";

    foreach my $command (keys %{$COMMANDS}) {
        # get target file's name and open it for writing
        my $writeFile = BuildFilepath($COMMANDS->{$command}->{dn}, $outputDir);
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

        print FH "object ".$type."Command \"$COMMANDS->{$command}->{cn}\" {\n";
        print FH "\timport \"$template\"\n";
        foreach (keys %{$COMMANDS->{$command}}) {
            if ($_ =~ /commandline/) {
                my $command_line = escape_str($COMMANDS->{$command}->{$_}); # escape quotes

                # TODO translate macros
                # TODO detect $ARGn$
                print FH "//\$HOSTADDRESS\$ etc macro translation missing. See https://www.netways.org/issues/2557\"\n";


                print FH "\tcommand = \"$command_line\"\n";
            }
        }
        print FH "}\n";

        # close target file
        close(FH);
    }
}

#
# CONTACTS
#
sub genContacts {
    my $CONFIG = shift;
    my $target = shift;
    my $dir    = shift;
    my $outputDir;

    # set output dir
    if (defined $dir) { $outputDir = $dir; } else { $outputDir = $opt->{outputDir}; }

    # get all contacts
    my $CONTACTS = HashGrep($CONFIG, 'objectclass', $cfg->{ldap}->{prefix}.'Contact$');

    # check all contacts... are they below $cfg->{ldap}->{baseDN} ?
    # --> so contact objects in ou=Examples and ou=Templates will not be handled
    foreach my $val (keys %{$CONTACTS}) { delete $CONTACTS->{$val} if $val !~ /$cfg->{ldap}->{baseDN}$/; }

    # a special target is set?
    if (defined($target)) { foreach my $val (keys %{$CONTACTS}) { delete $CONTACTS->{$val} if $val !~ /$target$/; } }

    if (defined $cfg->{export}->{format} && $cfg->{export}->{format} == 2) {
        genContacts2x($CONTACTS, $outputDir);
    } else {
        genContacts1x($CONTACTS, $outputDir);
    }
}

sub genContacts1x {
    my $CONTACTS = shift;
    my $outputDir = shift;

    foreach my $contact (keys %{$CONTACTS}) {
        # get target file's name and open it for writing
        my $writeFile = BuildFilepath($CONTACTS->{$contact}->{dn}, $outputDir);
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

        print FH "define contact {\n";
        print FH "\tuse generic-contact\n";
        foreach(sort keys %{$CONTACTS->{$contact}}) {
            if ($itemMap{$_}) {
                if ($_ eq 'cn') {
                    print FH "\tcontact_name\t$CONTACTS->{$contact}->{$_}\n";
                } else {
                    print FH "\t$itemMap{$_}\t$CONTACTS->{$contact}->{$_}\n";
                }
            }
        }
        print FH "}\n";

        # close target file
        close(FH);

    }
}

sub genContacts2x {
    my $CONTACTS = shift;
    my $outputDir = shift;

    foreach my $contact (keys %{$CONTACTS}) {
        # get target file's name and open it for writing
        my $writeFile = BuildFilepath($CONTACTS->{$contact}->{dn}, $outputDir);
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

        print FH "object User \"$CONTACTS->{$contact}->{cn}\" {\n";
        print FH "\timport \"generic-user\"\n";
        if (defined $CONTACTS->{$contact}->{$cfg->{ldap}->{prefix}.'alias'}) {
            print FH "\tdisplay_name = \"$CONTACTS->{$contact}->{$cfg->{ldap}->{prefix}.'alias'}\"\n";
        } else {
            print FH "\tdisplay_name = \"$CONTACTS->{$contact}->{cn}\"\n";
        }

        foreach(sort keys %{$CONTACTS->{$contact}}) {
            if ($_ !~ /pager/ && $_ =~ /address/ && $_ !~ /email/) {
                print FH "\tvars.$itemMapIcinga2{$_} = \"$CONTACTS->{$contact}->{$_}\"\n";
            }
        }

        foreach(sort keys %{$CONTACTS->{$contact}}) {
            if ($_ =~ /pager/ || $_ =~ /email/) {
                print FH "\t\"$itemMapIcinga2{$_}\" = \"$CONTACTS->{$contact}->{$_}\"\n";
            }
        }

        print FH "}\n";

        # close target file
        close(FH);

    }
}

#
# CONTACTGROUPS
#
sub genContactgroups {
    my $CONFIG = shift;
    my $target = shift;
    my $dir    = shift;
    my $outputDir;

    # set output dir
    if (defined $dir) { $outputDir = $dir; } else { $outputDir = $opt->{outputDir}; }

    # get all contactgroups
    my $CONTACTGROUPS = HashGrep($CONFIG, 'objectclass', $cfg->{ldap}->{prefix}.'Contactgroup');

    # check all contactgroups... are they below $cfg->{ldap}->{baseDN} ?
    # --> so contactgroup objects in ou=Examples and ou=Templates will not be handled
    foreach my $val (keys %{$CONTACTGROUPS}) { delete $CONTACTGROUPS->{$val} if $val !~ /$cfg->{ldap}->{baseDN}$/; }

    # a special target is set?
    if (defined($target)) { foreach my $val (keys %{$CONTACTGROUPS}) { delete $CONTACTGROUPS->{$val} if $val !~ /$target$/; } }

    if (defined $cfg->{export}->{format} && $cfg->{export}->{format} == 2) {
        genContactgroups2x($CONTACTGROUPS, $outputDir);
    } else {
        genContactgroups1x($CONTACTGROUPS, $outputDir);
    }
}

sub genContactgroups1x {
    my $CONTACTGROUPS = shift;
    my $outputDir = shift;

    foreach my $contactgroup (keys %{$CONTACTGROUPS}) {
        # get target file's name and open it for writing
        my $writeFile = BuildFilepath($CONTACTGROUPS->{$contactgroup}->{dn}, $outputDir);
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

        print FH "define contactgroup {\n";
        foreach (sort keys %{$CONTACTGROUPS->{$contactgroup}}) {
            if ($itemMap{$_}) {
                if ($_ eq 'cn') {
                    print FH "\tcontactgroup_name\t$CONTACTGROUPS->{$contactgroup}->{$_}\n";
                } else {
                    print FH "\t$itemMap{$_}\t$CONTACTGROUPS->{$contactgroup}->{$_}\n";
                }
            }
        }
        print FH "}\n";

        # close target file
        close(FH);
    }
}

sub genContactgroups2x {
    my $CONTACTGROUPS = shift;
    my $outputDir = shift;

    foreach my $contactgroup (keys %{$CONTACTGROUPS}) {
        # get target file's name and open it for writing
        my $writeFile = BuildFilepath($CONTACTGROUPS->{$contactgroup}->{dn}, $outputDir);
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

        print FH "object UserGroup \"$CONTACTGROUPS->{$contactgroup}->{cn}\" {\n";
        if (defined $CONTACTGROUPS->{$contactgroup}->{$cfg->{ldap}->{prefix}.'alias'}) {
            print FH "\tdisplay_name = \"$CONTACTGROUPS->{$contactgroup}->{$cfg->{ldap}->{prefix}.'alias'}\"\n";
        } else {
            print FH "\tdisplay_name = \"$CONTACTGROUPS->{$contactgroup}->{cn}\"\n";
        }
        print FH "}\n";

        # close target file
        close(FH);
    }
}

#
# HOSTGROUPS
#
sub genHostgroups {
    my $CONFIG  = shift;
    my $CLIENTS = shift;
    my $target  = shift;
    my $dir    = shift;
    my $outputDir;

    # set output dir
    if (defined $dir) { $outputDir = $dir; } else { $outputDir = $opt->{outputDir}; }

    # get all hostgroups defined by hostgroup object
    my $HOSTGROUPS = HashGrep($CONFIG, 'objectclass', $cfg->{ldap}->{prefix}.'Hostgroup');

    # check all hostgroups... are they below $cfg->{ldap}->{baseDN} ?
    # --> so hostgroups objects in ou=Examples and ou=Templates will not be handled
    foreach my $val (keys %{$HOSTGROUPS}) { delete $HOSTGROUPS->{$val} if $val !~ /$cfg->{ldap}->{baseDN}$/; }

    # a special target is set?
    if (defined($target)) { foreach my $val (keys %{$HOSTGROUPS}) { delete $HOSTGROUPS->{$val} if $val !~ /$target$/; } }

    # process hostgroups by hostgroup object
    foreach my $hostgroup (keys %{$HOSTGROUPS}) {
        # if there are 'member'-attributes, push the values to $CLIENT hash
        if (defined $HOSTGROUPS->{$hostgroup}->{$cfg->{ldap}->{prefix}.'members'}) {
            # multiple values? split...
            my @hosts = split(/\,/, $HOSTGROUPS->{$hostgroup}->{$cfg->{ldap}->{prefix}.'members'});
            foreach my $host (@hosts) {
                # find the right host
                my $tmp_hash = HashGrep($CLIENTS, 'objectclass', $cfg->{ldap}->{prefix}.'Host');
                my $hostsearch = HashGrep($tmp_hash, 'dn', '^cn='.$host.',');
                foreach my $val1 (keys %{$hostsearch}) {
                    if (defined $CLIENTS->{$val1}->{$cfg->{ldap}->{prefix}.'hostgroups'}) {
                        $CLIENTS->{$val1}->{$cfg->{ldap}->{prefix}.'hostgroups'} .= ','.$HOSTGROUPS->{$hostgroup}->{cn};
                    } else {
                        $CLIENTS->{$val1}->{$cfg->{ldap}->{prefix}.'hostgroups'} .= $HOSTGROUPS->{$hostgroup}->{cn};
                    }

                    # TODO if there are escalations for this hostgroup, add them to the host itsself (Icinga 2.x)
                }
            }
        }

        # generate hostgroup host escalations
        genHostgroupEscalations($CONFIG, $CLIENTS, $outputDir, $hostgroup);
    }

    # get all hostgroups defined by hostobject
    foreach my $client (keys %{$CLIENTS}) {
        if (defined $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostgroups"}) {
            # multiple or a single hostgroup?
            if ($CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostgroups"} =~ /,/) {
                my @val = split(/\s*,\s*/, $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostgroups"});
                foreach(@val) { $HOSTGROUPS->{$_}->{cn} = $_ if $_ ne ''; }
            } else {
                $HOSTGROUPS->{$CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostgroups"}}->{cn} = $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostgroups"};
            }

            # look for host's hostgroups and their services (seperated logic)
            my @hhgs = split(/\s*,\s*/, $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostgroups"});
            foreach my $hg (@hhgs) {
                # find the right hostgroup
                my $hostgroup = HashGrep($HOSTGROUPS, 'dn', '^cn='.$hg.',');
                # only one, but we'll get a hash anyways
                foreach my $hostgroupdn (keys %{$hostgroup}) {
                    DebugOutput("GENERATE HOSTGROUPCONFIG", "Generate host services for hostgroup '$hg'", 1);
                    # look for services below hostgroup
                    my $hg_result = HashGrep($CONFIG, 'dn', '^[\w]+=[._\w\/\d\s:-]+,'.$hostgroupdn);
                    my $HOSTGROUPSERVICES = HashGrep($hg_result, 'objectclass', $cfg->{ldap}->{prefix}.'Service$');
                    foreach my $service (keys %{$HOSTGROUPSERVICES}) {
                        DebugOutput("GENERATE HOSTGROUPCONFIG", " HostDN: '$client'", 1);
                        DebugOutput("GENERATE HOSTGROUPCONFIG", " ServiceDN: '$service'", 1);
                        # we'll override all host SERVICES if there are duplicates
                        # clone the hash to prevent wrong references on dumping host services
                        $CLIENTS->{$client}->{SERVICES}->{$HOSTGROUPSERVICES->{$service}->{'cn'}} = dclone($HOSTGROUPSERVICES->{$service});
                    }
                }

            }
        }
    }

    if (defined $cfg->{export}->{format} && $cfg->{export}->{format} == 2) {
        genHostgroups2x($HOSTGROUPS, $outputDir);
    } else {
        genHostgroups1x($HOSTGROUPS, $outputDir);
    }
}

sub genHostgroups1x {
    my $HOSTGROUPS = shift;
    my $outputDir = shift;

    # write hostgroup files
    foreach my $hostgroup (keys %{$HOSTGROUPS}) {
        # set file path
        my $writeFile = $outputDir."/hostgroups/$HOSTGROUPS->{$hostgroup}->{cn}.cfg";

        # open target file
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";
        print FH "define hostgroup {\n";
        print FH "\thostgroup_name\t$HOSTGROUPS->{$hostgroup}->{cn}\n";
        if (defined $HOSTGROUPS->{$hostgroup}->{$cfg->{ldap}->{prefix}.'alias'}) {
            print FH "\talias\t$HOSTGROUPS->{$hostgroup}->{$cfg->{ldap}->{prefix}.'alias'}\n";
        } else {
            print FH "\talias\t$HOSTGROUPS->{$hostgroup}->{cn}\n";
        }
        print FH "}\n";

        # close target file
        close(FH);
    }
}

sub genHostgroups2x {
    my $HOSTGROUPS = shift;
    my $outputDir = shift;

    # write hostgroup files
    foreach my $hostgroup (keys %{$HOSTGROUPS}) {
        # set file path
        my $writeFile = $outputDir."/hostgroups/$HOSTGROUPS->{$hostgroup}->{cn}.conf";

        # open target file
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";
        print FH "object HostGroup \"$HOSTGROUPS->{$hostgroup}->{cn}\" {\n";
        if (defined $HOSTGROUPS->{$hostgroup}->{$cfg->{ldap}->{prefix}.'alias'}) {
            print FH "\tdisplay_name = \"$HOSTGROUPS->{$hostgroup}->{$cfg->{ldap}->{prefix}.'alias'}\"\n";
        } else {
            print FH "\tdisplay_name = \"$HOSTGROUPS->{$hostgroup}->{cn}\"\n";
        }
        print FH "}\n";

        # close target file
        close(FH);
    }
}

sub genHostgroupEscalations {
    my $CONFIG  = shift;
    my $CLIENTS = shift;
    my $outputDir = shift;
    my $hostgroup = shift;

    # Search for escalations below of a hostgroupgroup
    my $he_result = HashGrep($CONFIG, 'dn', '^[\w]+=[._\w\/\d\s:-]+,'.$hostgroup);
    my $HOSTESCALATIONS = HashGrep($he_result, 'objectclass', $cfg->{ldap}->{prefix}.'hostescalation$');

    if (defined $cfg->{export}->{format} && $cfg->{export}->{format} == 2) {
        genHostgroupEscalations2x($CONFIG, $CLIENTS, $HOSTESCALATIONS, $hostgroup, $outputDir);
    } else {
        genHostgroupEscalations1x($CONFIG, $HOSTESCALATIONS, $hostgroup, $outputDir);
    }
}

sub genHostgroupEscalations1x {
    my $CONFIG  = shift;
    my $HOSTESCALATIONS  = shift;
    my $hostgroup = shift;
    my $outputDir = shift;

    foreach my $escalation (keys %{$HOSTESCALATIONS}) {
        my $writeFile = $outputDir."/hostescalations/$he_result->{$escalation}->{cn}.cfg";

        # open target file
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";
        print FH "define hostescalation {\n";
        print FH "\t$itemMap{lconfhostescalationhostgroups}\t$CONFIG->{$hostgroup}->{cn}\n";

        foreach my $val1 (sort keys %{$he_result->{$escalation}}) {
            if ($val1 =~ /$cfg->{ldap}->{prefix}hostescalation/) {
                print FH "\t$itemMap{$val1}\t$he_result->{$escalation}->{$val1}\n";
            }
        }
        print FH "}\n\n";

        # close target file
        close(FH);
    }
}
#FIXME stash escalations as host notifications for each host inside the hostgroup (see above)
sub genHostgroupEscalations2x {
    my $CONFIG  = shift;
    my $CLIENTS = shift;
    my $HOSTESCALATIONS  = shift;
    my $hostgroup = shift;
    my $outputDir = shift;

    foreach my $escalation (keys %{$HOSTESCALATIONS}) {
=pod
        my $writeFile = $outputDir."/hostescalations/$he_result->{$escalation}->{cn}.cfg";

        # open target file
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";
        print FH "define hostescalation {\n";
        print FH "\t$itemMap{lconfhostescalationhostgroups}\t$CONFIG->{$hostgroup}->{cn}\n";

        foreach my $val1 (sort keys %{$he_result->{$escalation}}) {
            if ($val1 =~ /$cfg->{ldap}->{prefix}hostescalation/) {
                print FH "\t$itemMap{$val1}\t$he_result->{$escalation}->{$val1}\n";
            }
        }
        print FH "}\n\n";

        # close target file
        close(FH);
=cut
    }
}

#
# SERVICEGROUPS
#
sub genServicegroups {
    my $CONFIG  = shift;
    my $CLIENTS = shift;
    my $target  = shift;
    my $dir     = shift;
    my $outputDir;

    # set output dir
    if (defined $dir) { $outputDir = $dir; } else { $outputDir = $opt->{outputDir}; }

    # get all hostgroups defined by hostgroup object
    my $SERVICEGROUPS = HashGrep($CONFIG, 'objectclass', $cfg->{ldap}->{prefix}.'Servicegroup');

    # check all servicegroups... are they below $cfg->{ldap}->{baseDN} ?
    # --> so servicegroups objects in ou=Examples and ou=Templates will not be handled
    foreach my $val (keys %{$SERVICEGROUPS}) { delete $SERVICEGROUPS->{$val} if $val !~ /$cfg->{ldap}->{baseDN}$/; }

    # a special target is set?
    if (defined($target)) { foreach my $val (keys %{$SERVICEGROUPS}) { delete $SERVICEGROUPS->{$val} if $val !~ /$target$/; } }

    # process servicegroups
    foreach my $servicegroup (keys %{$SERVICEGROUPS}) {
        # if there are 'member'-attributes, push the values to $CLIENT hash
        if (defined $SERVICEGROUPS->{$servicegroup}->{$cfg->{ldap}->{prefix}.'members'}) {
            my @val = split(/\s*,\s*/, $SERVICEGROUPS->{$servicegroup}->{"$cfg->{ldap}->{prefix}members"});
            my $counter = 0;

            while($counter <= $#val) {
                # search full name in client hash :(
                foreach my $client (keys %{$CLIENTS}) {
                    # if real name was found, add to $CLIENT hash
                    if ($client =~ /^cn=$val[$counter],/) {
                        if ($CLIENTS->{$client}->{SERVICES}->{$val[$counter+1]}->{"$cfg->{ldap}->{prefix}servicegroups"}) {
                            $CLIENTS->{$client}->{SERVICES}->{$val[$counter+1]}->{"$cfg->{ldap}->{prefix}servicegroups"} = $CLIENTS->{$client}->{SERVICES}->{$val[$counter+1]}->{"$cfg->{ldap}->{prefix}servicegroups"}.','.$result->{$servicegroup}->{'cn'};
                        } else {
                            $CLIENTS->{$client}->{SERVICES}->{$val[$counter+1]}->{"$cfg->{ldap}->{prefix}servicegroups"} = $SERVICEGROUPS->{$servicegroup}->{'cn'};
                        }

                        # TODO find service escalations below servicegroup and add to services as notification with begin/end time
                    }
                }

                $counter = $counter+2;
            }
        }

        # look for service escalations below servicegroup
        genServicegroupEscalations($CONFIG, $CLIENTS, $outputDir, $servicegroup);
      }

    # get all servicegroups defined by serviceobject
    foreach my $client (keys %{$CLIENTS}) {
        foreach my $service (keys %{$CLIENTS->{$client}->{SERVICES}}) {
            if (defined $CLIENTS->{$client}->{SERVICES}->{$service}->{"$cfg->{ldap}->{prefix}servicegroups"}) {
                # multiple or a single servicegroup?
                if ($CLIENTS->{$client}->{SERVICES}->{$service}->{"$cfg->{ldap}->{prefix}servicegroups"} =~ /,/) {
                    my @val = split(/\s*,\s*/, $CLIENTS->{$client}->{SERVICES}->{$service}->{"$cfg->{ldap}->{prefix}servicegroups"});
                    foreach(@val) { $SERVICEGROUPS->{$_}->{cn} = $_ if $_ ne ''; }
                } else {
                    $SERVICEGROUPS->{$CLIENTS->{$client}->{SERVICES}->{$service}->{"$cfg->{ldap}->{prefix}servicegroups"}}->{cn} = $CLIENTS->{$client}->{SERVICES}->{$service}->{"$cfg->{ldap}->{prefix}servicegroups"};
                }
            }
        }
    }

    if (defined $cfg->{export}->{format} && $cfg->{export}->{format} == 2) {
        genServicegroups2x($SERVICEGROUPS, $outputDir);
    } else {
        genServicegroups1x($SERVICEGROUPS, $outputDir);
    }
}

sub genServicegroups1x {
    my $SERVICEGROUPS = shift;
    my $outputDir = shift;

    # write servicegroup files
    foreach my $servicegroup (keys %{$SERVICEGROUPS}) {
        # set file path
        my $writeFile = $outputDir."/servicegroups/$SERVICEGROUPS->{$servicegroup}->{cn}.cfg";

        # open target file
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";
        print FH "define servicegroup {\n";
        print FH "\tservicegroup_name\t$SERVICEGROUPS->{$servicegroup}->{cn}\n";
        if (defined $SERVICEGROUPS->{$servicegroup}->{$cfg->{ldap}->{prefix}.'alias'}) {
            print FH "\talias\t$SERVICEGROUPS->{$servicegroup}->{$cfg->{ldap}->{prefix}.'alias'}\n";
        } else {
            print FH "\talias\t$SERVICEGROUPS->{$servicegroup}->{cn}\n";
        }
        print FH "}\n";

        # close target file
        close(FH);
    }
}

sub genServicegroups2x {
    my $SERVICEGROUPS = shift;
    my $outputDir = shift;

    # write servicegroup files
    foreach my $servicegroup (keys %{$SERVICEGROUPS}) {
        # set file path
        my $writeFile = $outputDir."/servicegroups/$SERVICEGROUPS->{$servicegroup}->{cn}.conf";

        # open target file
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";
        print FH "object ServiceGroup \"$SERVICEGROUPS->{$servicegroup}->{cn}\" {\n";
        if (defined $SERVICEGROUPS->{$servicegroup}->{$cfg->{ldap}->{prefix}.'alias'}) {
            print FH "\tdisplay_name = \"$SERVICEGROUPS->{$servicegroup}->{$cfg->{ldap}->{prefix}.'alias'}\"\n";
        } else {
            print FH "\tdisplay_name = \"$SERVICEGROUPS->{$servicegroup}->{cn}\"\n";
        }
        print FH "}\n";

        # close target file
        close(FH);
    }
}

sub genServicegroupEscalations {
    my $CONFIG  = shift;
    my $CLIENTS = shift;
    my $outputDir = shift;
    my $servicegroup = shift;

    # Search for escalations below of a servicegroup
    my $se_result = HashGrep($CONFIG, 'dn', '^[\w]+=[._\w\/\d\s:-]+,'.$servicegroup);
    my $SERVICEESCALATIONS = HashGrep($se_result, 'objectclass', $cfg->{ldap}->{prefix}.'serviceescalation$');

    if (defined $cfg->{export}->{format} && $cfg->{export}->{format} == 2) {
        genServicegroupEscalations2x($CONFIG, $CLIENTS, $SERVICEESCALATIONS, $servicegroup, $outputDir);
    } else {
        genServicegroupEscalations1x($CONFIG, $SERVICEESCALATIONS, $servicegroup, $outputDir);
    }
}

sub genServicegroupEscalations1x {
    my $CONFIG  = shift;
    my $SERVICEESCALATIONS = shift;
    my $outputDir = shift;
    my $servicegroup = shift;

    foreach my $escalation (keys %{$SERVICEESCALATIONS}) {
        my $writeFile = $outputDir."/serviceescalations/$se_result->{$escalation}->{cn}.cfg";

        # open target file
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";
        print FH "define serviceescalation {\n";
        print FH "\t$itemMap{lconfserviceescalationservicegroups}\t$CONFIG->{$servicegroup}->{cn}\n";

        foreach my $val1 (sort keys %{$se_result->{$escalation}}) {
            if ($val1 =~ /$cfg->{ldap}->{prefix}serviceescalation/) {
                print FH "\t$itemMap{$val1}\t$se_result->{$escalation}->{$val1}\n";
            }
        }
        print FH "}\n\n";

        # close target file
        close(FH);
    }
}

sub genServicegroupEscalations2x {
    my $CONFIG  = shift;
    my $CLIENTS = shift;
    my $SERVICEESCALATIONS = shift;
    my $outputDir = shift;
    my $servicegroup = shift;

=pod
    foreach my $escalation (keys %{$SERVICEESCALATIONS}) {
        my $writeFile = $outputDir."/serviceescalations/$se_result->{$escalation}->{cn}.cfg";

        # open target file
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";
        print FH "define serviceescalation {\n";
        print FH "\t$itemMap{lconfserviceescalationservicegroups}\t$CONFIG->{$servicegroup}->{cn}\n";

        foreach my $val1 (sort keys %{$se_result->{$escalation}}) {
            if ($val1 =~ /$cfg->{ldap}->{prefix}serviceescalation/) {
                print FH "\t$itemMap{$val1}\t$se_result->{$escalation}->{$val1}\n";
            }
        }
        print FH "}\n\n";

        # close target file
        close(FH);
    }
=cut
}

#
# ESCALATIONS
#

#
# HOSTS
#
sub genHostConfig {
    my $CONFIG  = shift;
    my $CLIENTS = shift;
    my $client = shift;
    my $dir    = shift;
    my $outputDir;

    # set output dir
    if (defined $dir) { $outputDir = $dir; } else { $outputDir = $opt->{outputDir}; }

    if (defined $cfg->{export}->{format} && $cfg->{export}->{format} == 2) {
        genHostConfig2x($CONFIG, $CLIENTS, $client, $outputDir);
    } else {
        genHostConfig1x($CONFIG, $CLIENTS, $client, $outputDir);
    }
}

sub genHostConfig1x {
    my $CONFIG  = shift;
    my $CLIENTS = shift;
    my $client = shift;
    my $outputDir = shift;

    DebugOutput("$$ GENERATE HOSTCONFIG 1x", "Generate config for $client", 1);
    if (defined $CLIENTS->{$client}->{dn}) {
        # only gen config if lconfhostdisable is not set
        if (!defined $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostdisable"}) {
            #
            # HOST DEFINITION
            #
            # get target file's name and open it for writing
            my $writeFile = BuildFilepath($CLIENTS->{$client}->{dn}, $outputDir);
            open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

            # generate host definition
            print FH "define host {\n";
            print FH "\tuse generic-host\n";
            print FH "\thost_name\t$CLIENTS->{$client}->{cn}\n";

            # process each item...
            foreach my $val1 (sort keys %{$CLIENTS->{$client}}) {
                # ...but look after type; only host items
                # and no service dependency attributes;
                # they will be handled in an other way
                if (($val1 =~ /$cfg->{ldap}->{prefix}host/ || $val1 eq "$cfg->{ldap}->{prefix}address" || $val1 eq "$cfg->{ldap}->{prefix}parent" || $val1 eq "$cfg->{ldap}->{prefix}alias") && $val1 !~ /$cfg->{ldap}->{prefix}hostdependency/) {
                    # customvar or a default item?
                    if ($val1 =~ /customvar/i) {
                        foreach my $val2 (sort keys %{$CLIENTS->{$client}->{$val1}}) {
                            print FH "\t$val2\t$CLIENTS->{$client}->{$val1}->{$val2}\n";
                        }
                    } else {
                        print FH "\t$itemMap{$val1}\t$CLIENTS->{$client}->{$val1}\n";
                    }
                }
            }

            # generate end of host definition
            print FH "}\n";
            print FH "\n";

            #
            # SERVICES
            #
            foreach my $service (keys %{$CLIENTS->{$client}->{'SERVICES'}}) {
                DebugOutput("$$ GENERATE HOSTCONFIG", "Found service $service", 1);
                # only gen service if lconfservicedisable is not set
                if (!defined $CLIENTS->{$client}->{'SERVICES'}->{$service}->{"$cfg->{ldap}->{prefix}servicedisable"}) {
                    print FH "define service {\n";
                    print FH "\tuse generic-service\n";
                    print FH "\tservice_description\t$CLIENTS->{$client}->{'SERVICES'}->{$service}->{cn}\n";
                    print FH "\thost_name\t$CLIENTS->{$client}->{cn}\n";

                    # process each item
                    foreach my $val1 (sort keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}}) {
                        # ...but look after type; only service items!
                        if (($val1 =~ /$cfg->{ldap}->{prefix}service/ || $val1 eq "$cfg->{ldap}->{prefix}checkcommand") && $val1 !~ /$cfg->{ldap}->{prefix}servicedependency/) {
                            # customvar or a default item?
                            if ($val1 =~ /customvar/i) {
                                foreach my $val2 (sort keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}}) {
                                    next if (!defined($val2) || $val2 eq "" ||
                                        $val2 eq "_" || !$CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}->{$val2});
                                    print FH "\t$val2\t$CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}->{$val2}\n";
                                }
                            } else {
                                print FH "\t$itemMap{$val1}\t$CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}\n";
                            }
                        }
                    }

                    print FH "}\n";
                    print FH "\n";
                } else {
                    DebugOutput("$$ GENERATE HOSTCONFIG 1x", "Skipping disabled service '$service' ", 1);
                }
            }

            #
            # HOST DEPENDENCIES
            #
            foreach my $dependency (sort keys %{$CLIENTS->{$client}->{'HOSTDEPENDENCY'}}) {
                # only if host is not disabled
                if (!$CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostdisable"}) {
                    print FH "define hostdependency {\n";
                    print FH "\thost_name\t$dependency\n";
                    print FH "\tdependent_host_name\t$CLIENTS->{$client}->{cn}\n";
                    foreach(sort keys %{$CLIENTS->{$client}->{HOSTDEPENDENCY}->{$dependency}}) {
                        print FH "\t$itemMap{$_}\t$CLIENTS->{$client}->{HOSTDEPENDENCY}->{$dependency}->{$_}\n" if $itemMap{$_};
                    }
                    print FH "}\n";
                    print FH "\n";
                }
            }

            #
            # SERVICE DEPENDENCIES
            #
            foreach my $service (sort keys %{$CLIENTS->{$client}->{'SERVICES'}}) {
                # only gen service if lconfservicedisable is not set
                if (!defined $CLIENTS->{$client}->{'SERVICES'}->{$service}->{"$cfg->{ldap}->{prefix}servicedisable"}) {
                    if (defined $CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEDEPENDENCY}) {
                        foreach my $dependency (sort keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEDEPENDENCY}}) {
                            my ($depHost, $depService) = (split(/ *-> */, $dependency))[0,1];

                            print FH "define servicedependency {\n";

                            # special stuff for inheritance :-(
                            if ($depHost eq "\$HOSTNAME\$") {
                                print FH "\thost_name\t$CLIENTS->{$client}->{cn}\n";
                            } else {
                                print FH "\thost_name\t$depHost\n";
                            }

                            print FH "\tservice_description\t$depService\n";
                            print FH "\tdependent_host_name\t$CLIENTS->{$client}->{cn}\n";
                            print FH "\tdependent_service_description\t$service\n";
                            foreach (sort keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEDEPENDENCY}->{$dependency}}) {
                                print FH "\t$itemMap{$_}\t$CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEDEPENDENCY}->{$dependency}->{$_}\n";
                            }
                            print FH "}\n";
                            print FH "\n";
                        }
                    }
                }
            }

            #
            # HOST ESCALATIONS
            #
            foreach my $escalation (sort keys %{$CLIENTS->{$client}->{'HOSTESCALATION'}}) {
                # only if host is not disabled
                if (!$CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostdisable"}) {
                    print FH "define hostescalation {\n";
                    print FH "\thost_name\t$CLIENTS->{$client}->{cn}\n";
                    foreach my $val (keys %{$CLIENTS->{$client}->{HOSTESCALATION}->{$escalation}}) {
                        print FH "\t$itemMap{$val}\t$CLIENTS->{$client}->{HOSTESCALATION}->{$escalation}->{$val}\n";
                    }
                    print FH "}\n";
                    print FH "\n";
                }
            }

            #
            # SERVICE ESCALATIONS
            #
            foreach my $service (sort keys %{$CLIENTS->{$client}->{'SERVICES'}}) {
                # only gen service if lconfservicedisable is not set
                if (!defined $CLIENTS->{$client}->{'SERVICES'}->{$service}->{"$cfg->{ldap}->{prefix}servicedisable"}) {
                    if (defined $CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEESCALATION}) {
                        foreach my $escalation (sort keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEESCALATION}}) {
                            print FH "define serviceescalation {\n";
                            print FH "\thost_name\t$CLIENTS->{$client}->{cn}\n";
                            print FH "\tservice_description\t$service\n";
                            foreach my $val (keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEESCALATION}->{$escalation}}) {
                                print FH "\t$itemMap{$val}\t$CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEESCALATION}->{$escalation}->{$val}\n";
                            }
                            print FH "}\n";
                            print FH "\n";
                        }
                    }
                }
            }
        } else {
            DebugOutput("$$ GENERATE HOSTCONFIG 1x", "Skipping disabled host '$client' ", 1);
        }
    }
}

sub genHostConfig2x {
    my $CONFIG  = shift;
    my $CLIENTS = shift;
    my $client = shift;
    my $outputDir = shift;

    DebugOutput("$$ GENERATE HOSTCONFIG 2x", "Generate config for $client", 1);

    # prepare contacts, contactgroups and commands once for later notification/eventhandler magic
    my $CONTACTGROUPS = HashGrep($CONFIG, 'objectclass', $cfg->{ldap}->{prefix}.'Contactgroup');
    my $CONTACTS = HashGrep($CONFIG, 'objectclass', $cfg->{ldap}->{prefix}.'Contact$');
    my $COMMANDS = HashGrep($CONFIG, 'objectclass', $cfg->{ldap}->{prefix}.'Command$');


    if (defined $CLIENTS->{$client}->{dn}) {
        # only gen config if lconfhostdisable is not set
        if (!defined $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostdisable"}) {

            my $notification_commands = ();
            my $event_commands = ();

            my $host = $CLIENTS->{$client}->{cn};
            #
            # HOST DEFINITION
            #
            my $vars = ();

            # get target file's name and open it for writing
            my $writeFile = BuildFilepath($CLIENTS->{$client}->{dn}, $outputDir);
            open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

            # generate host definition
            print FH "object Host \"$CLIENTS->{$client}->{cn}\" {\n";
            print FH "\timport \"generic-host\"\n";

            my $host_parents_str = "";
            # process each item...
            foreach my $val1 (sort keys %{$CLIENTS->{$client}}) {
                if ($val1 eq "$cfg->{ldap}->{prefix}address" ||
                    $val1 eq "$cfg->{ldap}->{prefix}address6" ||
                    $val1 eq "$cfg->{ldap}->{prefix}hostactionurl" ||
                    $val1 eq "$cfg->{ldap}->{prefix}hostnotesurl" ||
                    $val1 eq "$cfg->{ldap}->{prefix}hostnotes" ||
                    $val1 eq "$cfg->{ldap}->{prefix}iconimage" ||
                    $val1 eq "$cfg->{ldap}->{prefix}iconimagealt"
                    ) {
                    print FH "\t$itemMapIcinga2{$val1} = \"$CLIENTS->{$client}->{$val1}\"\n";

                } elsif ($val1 eq "$cfg->{ldap}->{prefix}statusmapimage") {
                    $vars->{$itemMapIcinga2{$val1}} = escape_str($CLIENTS->{$client}->{$val1});

                } elsif ($val1 =~ /customvar/i) {
                    foreach my $val2 (sort keys %{$CLIENTS->{$client}->{$val1}}) {
                        next if (!defined($val2) || $val2 eq "" ||
                                    $val2 eq "_" || !$CLIENTS->{$client}->{$val1}->{$val2});
                        $key = $val2;
                        $key =~ s/_//;
                        $vars->{$key} = escape_str($CLIENTS->{$client}->{$val1}->{$val2});
                    }

                } elsif ($val1 eq "$cfg->{ldap}->{prefix}parent") {
                    $host_parents_str = $CLIENTS->{$client}->{$val1};
                } elsif ($val1 eq "$cfg->{ldap}->{prefix}hostgroups") {
                    my $groups = $CLIENTS->{$client}->{$val1};
                    $groups =~ s/,/\", \"/g;
                    print FH "\tgroups = [ \"$groups\" ]\n";
                } elsif ($val1 eq "$cfg->{ldap}->{prefix}alias") {
                    print FH "\tdisplay_name = \"$CLIENTS->{$client}->{$val1}\"\n";
                } elsif ($val1 eq "$cfg->{ldap}->{prefix}hostcheckcommand" || $val1 eq "$cfg->{ldap}->{prefix}checkcommand") {

                    my $host_check_command_str = $CLIENTS->{$client}->{$val1};
                    my ($host_check_command_name, @host_check_command_args) = split /!/, $host_check_command_str;

                    my $arg_c = 1;
                    foreach my $macro_val (@host_check_command_args) {
                        # check command arg name for being an icinga 1.x macro and resolve its value
                        if ($macro_val =~ /^\$(\w+)\$$/) {
                            if ($1 =~ /^_HOST(\w+)/) {
                                my $cv_val_macro_key = "_".$1;
                                # override the original cv value
                                $macro_val = $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostcustomvar"}->{$cv_val_macro_key};
                            }
                        }

                        $vars->{'ARG'.$arg_c} = escape_str($macro_val);
                        $arg_c++;
                    }

                    if (defined($CLIENTS->{$client}->{$cfg->{ldap}->{prefix}.'hostcheckinterval'})) {
                        print FH "\tcheck_interval = $CLIENTS->{$client}->{$cfg->{ldap}->{prefix}.'hostcheckinterval'}m\n";
                    }
                    if (defined($CLIENTS->{$client}->{$cfg->{ldap}->{prefix}.'hostcheckretryinterval'})) {
                        print FH "\tcheck_interval = $CLIENTS->{$client}->{$cfg->{ldap}->{prefix}.'hostcheckretryinterval'}m\n";
                    }
                    if (defined($CLIENTS->{$client}->{$cfg->{ldap}->{prefix}.'hostmaxcheckattempts'})) {
                        print FH "\tmax_check_attempts = $CLIENTS->{$client}->{$cfg->{ldap}->{prefix}.'hostmaxcheckattempts'}\n";
                    }

                    print FH "\tcheck_command = \"$host_check_command_name\"\n";
                }
            }

            # custom attr
            foreach my $var (sort keys %{$vars}) {
                print FH "\tvars.$var = \"$vars->{$var}\"\n"
            }

            # generate end of host definition
            print FH "}\n";
            print FH "\n";

            # host dependencies
            if (defined($CLIENTS->{$client}->{'HOSTDEPENDENCY'})) {
                foreach my $dependency (sort keys %{$CLIENTS->{$client}->{HOSTDEPENDENCY}}) {
                    next if (!defined $dependency || $dependency eq "");

                    print FH "object Dependency \"$dependency\" {\n";

                    print FH "\tparent_host_name = \"$dependency\"\n";
                    print FH "\tchild_host_name = \"$CLIENTS->{$client}->{cn}\"\n";

                    foreach(sort keys %{$CLIENTS->{$client}->{HOSTDEPENDENCY}->{$dependency}}) {
                        if ($_ eq "$cfg->{ldap}->{prefix}hostdependencyexecutionfailurecriteria") {
                            my $fail_crit = convert_dependendy_failure_criteria_2x($CLIENTS->{$client}->{HOSTDEPENDENCY}->{$dependency}->{$_}, 'check', 1);
                            DebugOutput("$$ GENERATE HOSTCONFIG 2x", "HOSTDEPENDENCY exec: $CLIENTS->{$client}->{HOSTDEPENDENCY}->{$dependency}->{$_}: ".Dumper($fail_crit));
                            print FH "\tdisable_checks = true\n" if $fail_crit->{'runeverything'} == 0;
                            print FH "\tdisable_checks = false\n" if $fail_crit->{'runeverything'} == 1;
                            print FH "\tstates = [ ". (join ', ', @{$fail_crit->{'state'}}) ." ]\n"; # execution failure criteria is mandatory for state_filter
                        }
                        if ($_ eq "$cfg->{ldap}->{prefix}hostdependencynotificationfailurecriteria") {
                            my $fail_crit = convert_dependendy_failure_criteria_2x($CLIENTS->{$client}->{HOSTDEPENDENCY}->{$dependency}->{$_}, 'notification', 1);
                            DebugOutput("$$ GENERATE HOSTCONFIG 2x", "HOSTDEPENDENCY notif: $CLIENTS->{$client}->{HOSTDEPENDENCY}->{$dependency}->{$_}: ".Dumper($fail_crit));
                            print FH "\tdisable_notifications = true\n" if $fail_crit->{'runeverything'} == 0;
                            print FH "\tdisable_notifications = false\n" if $fail_crit->{'runeverything'} == 1;
                        }
                    }
                    print FH "}\n";
                }
            }

            # 1.x parents are 2.x dependencies with no attributes
            my @parent_dependencies = ();
            if ($host_parents_str ne "") {
                push @parent_dependencies, str2arr_by_delim_without_excludes($host_parents_str, ',', 1);
            }

            if (@parent_dependencies > 0) {
                foreach my $parent_host (@parent_dependencies) {
                    print FH "object Dependency \"$parent_host\" {\n";
                    print FH "\tparent_host_name = \"$parent_host\"\n";
                    print FH "\tchild_host_name = \"$CLIENTS->{$client}->{cn}\"\n";
                    print FH "}\n";
                }
            }

            print FH "\n";

            #
            # host notifications
            #

            # parse contacts, contactgroups
            my @users = ();
            if (defined($CLIENTS->{$client}->{$cfg->{ldap}->{prefix}.'hostcontactgroups'})) {
                foreach my $contactgroup (keys %{$CONTACTGROUPS}) {
                    #DebugOutput("$$ GENERATE HOSTCONFIG 2x", Dumper($CONTACTGROUPS->{$contactgroup}));
                    if ($CONTACTGROUPS->{$contactgroup}->{cn} eq $CLIENTS->{$client}->{$cfg->{ldap}->{prefix}.'hostcontactgroups'}) {
                        my @members = split /,/, $CONTACTGROUPS->{$contactgroup}->{$cfg->{ldap}->{prefix}.'members'};
                        push @users, @members;
                    }
                }
            } else {
                #DebugOutput("$$ GENERATE HOSTCONFIG 2x", "Skipping $CLIENTS->{$client}->{cn} notification, no contactgroups found.");
            }

            if (defined($CLIENTS->{$client}->{$cfg->{ldap}->{prefix}.'hostcontacts'})) {
                my @contacts = split /,/, $CLIENTS->{$client}->{$cfg->{ldap}->{prefix}.'hostcontacts'};
                push @users, @contacts;
            } else {
                #DebugOutput("$$ GENERATE HOSTCONFIG 2x", "Skipping $CLIENTS->{$client}->{cn} notification, no contacts found.");
            }

            if (@users) {
                # make sure that group members and contacts remain unique
                @users = uniq(@users);
                #DebugOutput("$$ GENERATE HOSTCONFIG 2x", Dumper(@users));
            }

            # now that we've got all users, get their notification commands
            foreach my $user (@users) {
                my $notification_cnt = 0;
                #DebugOutput("$$ GENERATE HOSTCONFIG 2x", "Looking for user $user in ".Dumper($CONTACTS));

                foreach my $contact (keys %{$CONTACTS}) {
                    #DebugOutput("$$ GENERATE HOSTCONFIG 2x", "Looking for user $user in ".Dumper($CONTACTS->{$contact}));

                    if ($CONTACTS->{$contact}->{cn} eq $user) {
                        DebugOutput("$$ GENERATE HOSTCONFIG 2x", "Building notification for host '$CLIENTS->{$client}->{cn}' and user '$user'");

                        # build the notification based on the commands
                        my @host_notification_commands = split /,/, $CONTACTS->{$contact}->{$cfg->{ldap}->{prefix}.'contacthostnotificationcommands'};

                        foreach my $notification_command_name (@host_notification_commands) {
                            my $notification_name = "host-".$CLIENTS->{$client}->{cn}."-".$notification_command_name."-".$notification_cnt;

                            my $notification_command_object_name = "notification-".$notification_name; # generate a unique command name for this notification

                            print FH "object Notification \"$notification_name\" {\n";
                            print FH "\timport \"mail-host-notification\"\n";

                            print FH "\thost_name = \"$CLIENTS->{$client}->{cn}\"\n";

                            # get the command line, add a new notification command
                            my $notification_command_line; # we don't have args for notification commands
                            foreach my $command (keys %{$COMMANDS}) {
                                if ($COMMANDS->{$command}->{cn} eq $notification_command_name) {
                                    $notification_command_line = escape_str($COMMANDS->{$command}->{$cfg->{ldap}->{prefix}.'commandline'});
                                    goto FOUND_NOTIFICATION;
                                }
                            }

                            FOUND_NOTIFICATION:

                            $notification_commands->{$notification_command_object_name} = $notification_command_line;

                            # notification command
                            print FH "\tcommand = \"$notification_command_object_name\"\n";

                            # notification options
                            if (defined($CLIENTS->{$client}->{$cfg->{ldap}->{prefix}.'hostnotificationoptions'})) {
                                my $notification_filters = convert_notification_options_to_filter_2x($CLIENTS->{$client}->{$cfg->{ldap}->{prefix}.'hostnotificationoptions'}, 1);

                                foreach my $by (keys %{$notification_filters}) {
                                    next if !@{$notification_filters->{$by}};
                                    my $notification_filter;
                                    if (grep /0/, @{$notification_filters->{$by}}) {
                                        $notification_filter = 0;
                                    } else {
                                        $notification_filter = "[ ". (join ', ', @{$notification_filters->{$by}}) ." ]";
                                    }
                                    print FH "\t".$by."s = $notification_filter\n";
                                }
                            }

                            # notification period
                            if (defined($CLIENTS->{$client}->{$cfg->{ldap}->{prefix}.'servicenotificationperiod'})) {
                                print FH "\tperiod = \"$CLIENTS->{$client}->{$cfg->{ldap}->{prefix}.'servicenotificationperiod'})\"";
                            }

                            print FH "\tusers = [ \"$user\" ]\n";

                            print FH "}\n";
                            print FH "\n";

                            # next notification
                            $notification_cnt++;
                        }
                    }
                }
            }

            #
            # service escalations as notification with begin/end
            #

            if (defined $CLIENTS->{$client}->{HOSTESCALATION}) {
                foreach my $escalation (sort keys %{$CLIENTS->{$client}->{HOSTESCALATION}}) {

                    my $host_escalation_firstnotification = $CLIENTS->{$client}->{HOSTESCALATION}->{$escalation}->{$cfg->{ldap}->{prefix}.'hostescalationfirstnotification'};
                    my $host_escalation_lastnotification = $CLIENTS->{$client}->{HOSTESCALATION}->{$escalation}->{$cfg->{ldap}->{prefix}.'hostescalationlastnotification'};
                    my $host_escalation_notificationinterval = $CLIENTS->{$client}->{HOSTESCALATION}->{$escalation}->{$cfg->{ldap}->{prefix}.'hostescalationnotificationinterval'};
                    my $host_escalation_contacts = $CLIENTS->{$client}->{HOSTESCALATION}->{$escalation}->{$cfg->{ldap}->{prefix}.'hostescalationcontacts'};
                    my $host_escalation_contactgroups = $CLIENTS->{$client}->{HOSTESCALATION}->{$escalation}->{$cfg->{ldap}->{prefix}.'hostescalationcontactgroups'};

                    my $begin;
                    my $end;

                    print FH "object Notification \"$escalation\" {\n";
                    print FH "\timport \"mail-host-notification\"\n";

                    # if missing, set a default of 5m
                    if (!defined($host_escalation_notificationinterval)) {
                        $host_escalation_notificationinterval = 5;
                    }

                    print FH "\ttimes = {\n";

                    if (defined($host_escalation_firstnotification)) {
                        $begin = $host_escalation_firstnotification * $host_escalation_notificationinterval;
                        print FH "\t\tbegin = ".$begin."m,\n";
                    }

                    if (defined($service_escalation_lastnotification)) {
                        $end = $host_escalation_lastnotification * $host_escalation_notificationinterval;
                        print FH "\t\tend = ".$end."m,\n";
                    }

                    print FH "\t}\n";

                    if (defined($host_escalation_contacts)) {
                        my @users = split /,/, $host_escalation_contacts;
                        print FH "\tusers = [ \"".join("\", \"", @users)."\" ],\n";
                    }
                    if (defined($host_escalation_contactgroups)) {
                        my @usergroups = split /,/, $host_escalation_contactgroups;
                        print FH "\tuser_groups = [ \"".join("\", \"", @usergroups)."\" ],\n";
                    }

                    print FH "}\n";
                    print FH "\n";

                }
            }

            #
            # SERVICES
            #
            foreach my $service (keys %{$CLIENTS->{$client}->{'SERVICES'}}) {

                DebugOutput("$$ GENERATE HOSTCONFIG 2x", "Found service $service", 1);

                # only gen service if lconfservicedisable is not set
                if (!defined $CLIENTS->{$client}->{'SERVICES'}->{$service}->{"$cfg->{ldap}->{prefix}servicedisable"}) {
                    print FH "object Service \"$CLIENTS->{$client}->{'SERVICES'}->{$service}->{cn}\" {\n";
                    print FH "\timport \"generic-service\"\n";

                    print FH "\thost_name = \"$CLIENTS->{$client}->{cn}\"\n";

                    # initialize each service macro / custom dict
                    my $vars_svc = ();

                    #
                    # ordinary service attributes
                    #

                    # process each item
                    foreach my $val1 (sort keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}}) {

                        # ...but look after type; only service items!

                        #
                        # default service attributes
                        #

                        # check command with macro arguments
                        if ($val1 eq "$cfg->{ldap}->{prefix}servicecheckcommand" || $val1 eq "$cfg->{ldap}->{prefix}checkcommand") {
                            my ($checkcommand_name, @checkcommand_macros) = split /!/, "$CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}";

                            my $arg_c = 1;
                            foreach my $macro_val (@checkcommand_macros) {
                                # check command arg name for being an icinga 1.x macro and resolve its value
                                if ($macro_val =~ /^\$(\w+)\$$/) {
                                    if ($1 =~ /^_HOST(\w+)/) {
                                        my $cv_val_macro_key = "_".$1;
                                        # override the original cv value with the resolved host cv
                                        $macro_val = $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostcustomvar"}->{$cv_val_macro_key};
                                    }
                                    elsif ($1 =~ /^_SERVICE(\w+)/) {
                                        my $cv_val_macro_key = "_".$1;
                                        # override the original cv value with the resolved service cv
                                        $macro_val = $CLIENTS->{$client}->{'SERVICES'}->{$service}->{"$cfg->{ldap}->{prefix}servicecustomvar"}->{$cv_val_macro_key};
                                    }
                                }

                                $vars_svc->{'ARG'.$arg_c} = escape_str($macro_val);

                                $arg_c++;
                            }

                            print FH "\tcheck_command = \"$checkcommand_name\"\n";

                        }
                        elsif ($val1 eq "$cfg->{ldap}->{prefix}serviceactionurl" ||
                               $val1 eq "$cfg->{ldap}->{prefix}servicenotesurl" ||
                               $val1 eq "$cfg->{ldap}->{prefix}servicenotes" ||
                               $val1 eq "$cfg->{ldap}->{prefix}iconimage" ||
                               $val1 eq "$cfg->{ldap}->{prefix}iconimagealt"
                               ) {
                            print FH "\t\t$itemMapIcinga2{$val1} = \"$CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}\"\n";
                        }
                        elsif ($val1 =~ /servicegroups/i) {
                            my $groups = $CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1};
                            $groups =~ s/,/\", \"/g;
                            print FH "\t\tgroups = [ \"$groups\" ],\n";
                        } elsif ($val1 =~ /checkinterval/i) {
                            print FH "\t\tcheck_interval = $CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}m,\n";
                        } elsif ($val1 =~ /retryinterval/i) {
                            print FH "\t\tretry_interval = $CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}m,\n";
                        } elsif ($val1 =~ /maxcheckattempts/i) {
                            print FH "\t\tmax_check_attempts = $CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1},\n";
                        } elsif ($val1 =~ /customvar/i) {
                            foreach my $val2 (sort keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}}) {
                                next if (!defined($val2) || $val2 eq "" ||
                                    $val2 eq "_" || !$CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}->{$val2});
                                $key = $val2;
                                $key =~ s/_//;
                                $vars_svc->{$key} = escape_str($CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}->{$val2});
                            }
                        } elsif ($val1 eq "$cfg->{ldap}->{prefix}serviceeventhandler") {

                            my $event_command_name = $CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1};
                            my $event_command_object_name = "$service-$event_command_name";

                            my $event_command_line; # we don't have args for notification commands
                            foreach my $command (keys %{$COMMANDS}) {
                                if ($COMMANDS->{$command}->{cn} eq $event_command_name) {
                                    $event_command_line = escape_str($COMMANDS->{$command}->{$cfg->{ldap}->{prefix}.'commandline'});
                                    goto FOUND_EVENT;
                                }
                            }

                            FOUND_EVENT:

                            $event_commands->{$event_command_object_name} = $event_command_line;

                            print FH "\t\tevent_command = \"$event_command_object_name\",\n";

                        } else { # FIXME different check_interval, quote notation
                            #print FH "\t\t$itemMapIcinga2{$val1} = $CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1},\n";
                        }
                    }

                    foreach my $var (sort keys %{$vars_svc}) {
                        print FH "\tvars.$var = \"$vars_svc->{$var}\"\n";
                    }

                    print FH "}\n";
                    print FH "\n";

                    #
                    # service dependencies
                    #
                    if (defined $CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEDEPENDENCY}) {
                        foreach my $dependency (sort keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEDEPENDENCY}}) {
                            my ($depHost, $depService) = (split(/ *-> */, $dependency))[0,1];

                            print FH "object Dependency \"$depHost-$depService\" {\n";

                            # special stuff for inheritance
                            if ($depHost eq "\$HOSTNAME\$") {
                                $depHost = $CLIENTS->{$client}->{cn};
                            }

                            print FH "\tparent_host_name = \"$depHost\"\n";
                            print FH "\tparent_service_name = \"$depService\"\n";
                            print FH "\tchild_host_name = \"$CLIENTS->{$client}->{cn}\"\n";
                            print FH "\tchild_service_name = \"$service\"\n";

                            foreach (sort keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEDEPENDENCY}->{$dependency}}) {
                                if ($_ eq "$cfg->{ldap}->{prefix}servicedependencyexecutionfailurecriteria") {
                                    my $fail_crit = convert_dependendy_failure_criteria_2x($CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEDEPENDENCY}->{$dependency}->{$_}, 'check', 0);
                                    DebugOutput("$$ GENERATE HOSTCONFIG 2x", "SERVICEDEPENDENCY: exec: $CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEDEPENDENCY}->{$dependency}->{$_}: ".Dumper($fail_crit));
                                    print FH "\tdisable_checks = true\n" if $fail_crit->{'runeverything'} == 0;
                                    print FH "\tdisable_checks = false\n" if $fail_crit->{'runeverything'} == 1;
                                    print FH "\tstates = [ ". (join ', ', @{$fail_crit->{'state'}}) ." ]\n"; # execution failure criteria is mandatory for state_filter
                                }
                                if ($_ eq "$cfg->{ldap}->{prefix}servicedependencynotificationfailurecriteria") {
                                    my $fail_crit = convert_dependendy_failure_criteria_2x($CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEDEPENDENCY}->{$dependency}->{$_}, 'notification', 0);
                                    DebugOutput("$$ GENERATE HOSTCONFIG 2x", "SERVICEDEPENDENCY: notif: $CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEDEPENDENCY}->{$dependency}->{$_}: ".Dumper($fail_crit));
                                    print FH "\tdisable_notifications = true\n" if $fail_crit->{'runeverything'} == 0;
                                    print FH "\tdisable_notifications = false\n" if $fail_crit->{'runeverything'} == 1;
                                }
                            }
                            print FH "}\n";
                        }
                    }

                    #
                    # service notifications
                    #

                    # parse contacts, contactgroups
                    my @users = ();
                    if (defined($CLIENTS->{$client}->{'SERVICES'}->{$service}->{$cfg->{ldap}->{prefix}.'servicecontactgroups'})) {
                        foreach my $contactgroup (keys %{$CONTACTGROUPS}) {
                            #DebugOutput("$$ GENERATE HOSTCONFIG 2x", Dumper($CONTACTGROUPS->{$contactgroup}));
                            if ($CONTACTGROUPS->{$contactgroup}->{cn} eq $CLIENTS->{$client}->{'SERVICES'}->{$service}->{$cfg->{ldap}->{prefix}.'servicecontactgroups'}) {
                                my @members = split /,/, $CONTACTGROUPS->{$contactgroup}->{$cfg->{ldap}->{prefix}.'members'};
                                push @users, @members;
                            }
                        }
                    } else {
                        #DebugOutput("$$ GENERATE HOSTCONFIG 2x", "Skipping $service notification, no contactgroups found.");
                    }

                    if (defined($CLIENTS->{$client}->{'SERVICES'}->{$service}->{$cfg->{ldap}->{prefix}.'servicecontacts'})) {
                        my @contacts = split /,/, $CLIENTS->{$client}->{'SERVICES'}->{$service}->{$cfg->{ldap}->{prefix}.'servicecontacts'};
                        push @users, @contacts;
                    } else {
                        #DebugOutput("$$ GENERATE HOSTCONFIG 2x", "Skipping $service notification, no contacts found.");
                    }

                    if (@users) {
                        # make sure that group members and contacts remain unique
                        @users = uniq(@users);
                        #DebugOutput("$$ GENERATE HOSTCONFIG 2x", Dumper(@users));
                    }

                    # now that we've got all users, get their notification commands
                    foreach my $user (@users) {
                        my $notification_cnt = 0;
                        #DebugOutput("$$ GENERATE HOSTCONFIG 2x", "Looking for user $user in ".Dumper($CONTACTS));

                        foreach my $contact (keys %{$CONTACTS}) {
                            #DebugOutput("$$ GENERATE HOSTCONFIG 2x", "Looking for user $user in ".Dumper($CONTACTS->{$contact}));

                            if ($CONTACTS->{$contact}->{cn} eq $user) {
                                DebugOutput("$$ GENERATE HOSTCONFIG 2x", "Building notification for service '$service' and user '$user'");

                                # build the notification based on the commands
                                my @service_notification_commands = split /,/, $CONTACTS->{$contact}->{$cfg->{ldap}->{prefix}.'contactservicenotificationcommands'};

                                foreach my $notification_command_name (@service_notification_commands) {
                                    my $notification_name = "host-".$CLIENTS->{$client}->{cn}."-service-".$CLIENTS->{$client}->{'SERVICES'}->{$service}->{cn}."-".$notification_command_name."-".$notification_cnt;

                                    my $notification_command_object_name = "notification-".$notification_name; # generate a unique command name for this notification

                                    print FH "object Notification \"$notification_name\" {\n";
                                    print FH "\timport \"mail-service-notification\"\n";

                                    print FH "\thost_name = \"$CLIENTS->{$client}->{cn}\"\n";
                                    print FH "\tservice_name = \"$CLIENTS->{$client}->{'SERVICES'}->{$service}->{cn}\"\n";

                                    # get the command line, add a new notification command
                                    my $notification_command_line; # we don't have args for notification commands
                                    foreach my $command (keys %{$COMMANDS}) {
                                        if ($COMMANDS->{$command}->{cn} eq $notification_command_name) {
                                            $notification_command_line = escape_str($COMMANDS->{$command}->{$cfg->{ldap}->{prefix}.'commandline'});
                                            goto FOUND_NOTIFICATION;
                                        }
                                    }

                                    FOUND_NOTIFICATION:

                                    $notification_commands->{$notification_command_object_name} = $notification_command_line;

                                    # notification command
                                    print FH "\tcommand = \"$notification_command_object_name\"\n";

                                    # notification options
                                    if (defined($CLIENTS->{$client}->{'SERVICES'}->{$service}->{$cfg->{ldap}->{prefix}.'servicenotificationoptions'})) {
                                        my $notification_filters = convert_notification_options_to_filter_2x($CLIENTS->{$client}->{'SERVICES'}->{$service}->{$cfg->{ldap}->{prefix}.'servicenotificationoptions'}, 0);

                                        foreach my $by (keys %{$notification_filters}) {
                                            next if !@{$notification_filters->{$by}};
                                            my $notification_filter;
                                            if (grep /0/, @{$notification_filters->{$by}}) {
                                                $notification_filter = 0;
                                            } else {
                                                $notification_filter = "[ ". (join ', ', @{$notification_filters->{$by}}) ." ]";
                                            }
                                            print FH "\t".$by."s = $notification_filter\n";
                                        }
                                    }

                                    # notification period
                                    if (defined($CLIENTS->{$client}->{'SERVICES'}->{$service}->{$cfg->{ldap}->{prefix}.'servicenotificationperiod'})) {
                                        print FH "\tperiod = \"$CLIENTS->{$client}->{'SERVICES'}->{$service}->{$cfg->{ldap}->{prefix}.'servicenotificationperiod'})\"";
                                    }

                                    print FH "\tusers = [ \"$user\" ]\n";

                                    print FH "}\n";
                                    print FH "\n";

                                    # next notification
                                    $notification_cnt++;
                                }
                            }
                        }
                    }

                    #
                    # service escalations as notification with begin/end
                    #

                    if (defined $CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEESCALATION}) {
                        foreach my $escalation (sort keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEESCALATION}}) {

                            my $service_escalation_firstnotification = $CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEESCALATION}->{$escalation}->{$cfg->{ldap}->{prefix}.'serviceescalationfirstnotification'};
                            my $service_escalation_lastnotification = $CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEESCALATION}->{$escalation}->{$cfg->{ldap}->{prefix}.'serviceescalationlastnotification'};
                            my $service_escalation_notificationinterval = $CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEESCALATION}->{$escalation}->{$cfg->{ldap}->{prefix}.'serviceescalationnotificationinterval'};
                            my $service_escalation_contacts = $CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEESCALATION}->{$escalation}->{$cfg->{ldap}->{prefix}.'serviceescalationcontacts'};
                            my $service_escalation_contactgroups = $CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEESCALATION}->{$escalation}->{$cfg->{ldap}->{prefix}.'serviceescalationcontactgroups'};

                            my $begin;
                            my $end;

                            print FH "object Notification \"$escalation\" {\n";
                            print FH "\timport \"mail-service-notification\"\n";

                            # if missing, set a default of 5m
                            if (!defined($service_escalation_notificationinterval)) {
                                $service_escalation_notificationinterval = 5;
                            }

                            print FH "\ttimes = {\n";

                            if (defined($service_escalation_firstnotification)) {
                                $begin = $service_escalation_firstnotification * $service_escalation_notificationinterval;
                                print FH "\t\tbegin = ".$begin."m,\n";
                            }

                            if (defined($service_escalation_lastnotification)) {
                                $end = $service_escalation_lastnotification * $service_escalation_notificationinterval;
                                print FH "\t\tend = ".$end."m,\n";
                            }

                            print FH "\t}\n";

                            if (defined($service_escalation_contacts)) {
                                my @users = split /,/, $service_escalation_contacts;
                                print FH "\tusers = [ \"".join("\", \"", @users)."\" ],\n";
                            }
                            if (defined($service_escalation_contactgroups)) {
                                my @usergroups = split /,/, $service_escalation_contactgroups;
                                print FH "\tuser_groups = [ \"".join("\", \"", @usergroups)."\" ],\n";
                            }

                            print FH "}\n";
                            print FH "\n";

                        }
                    }

                } else {
                    DebugOutput("$$ GENERATE HOSTCONFIG 2x", "Skipping disabled service '$service' ", 1);
                }

            }

            print FH "\n";

            # print additional commands generated by notifications and event handlers
            foreach my $notification_command_object_name (keys %{$notification_commands}) {
                print FH "object NotificationCommand \"$notification_command_object_name\" {\n";
                print FH "\timport \"plugin-notification-command\"\n";
                print FH "\tcommand = \"$notification_commands->{$notification_command_object_name}\"\n";
                print FH "}\n";
                print FH "\n";
            }

            foreach my $event_command_object_name (keys %{$event_commands}) {
                print FH "object EventCommand \"$event_command_object_name\" {\n";
                print FH "\timport \"plugin-event-command\"\n";
                print FH "\tcommand = \"$event_commands->{$event_command_object_name}\"\n";
                print FH "}\n";
                print FH "\n";
            }
        } else {
            DebugOutput("$$ GENERATE HOSTCONFIG 2x", "Skipping disabled host '$client' ", 1);
        }
    }
}

1;

# vi: sw=4 ts=4 expandtab :

