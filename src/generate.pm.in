# COPYRIGHT:
#
# This software is Copyright (c) 2010 - 2013 NETWAYS GmbH
#                                <support@netways.de>
#
# (Except where explicitly superseded by other copyright notices)
#
#
# LICENSE:
#
# This work is made available to you under the terms of Version 2 of
# the GNU General Public License. A copy of that license should have
# been provided with this software, but in any event can be snarfed
# from http://www.fsf.org.
#
# This work is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301 or visit their web page on the internet at
# http://www.fsf.org.
#
#
# CONTRIBUTION SUBMISSION POLICY:
#
# (The following paragraph is not intended to limit the rights granted
# to you to modify and distribute this software under the terms of
# the GNU General Public License and is only of importance to you if
# you choose to contribute your changes and enhancements to the
# community by submitting them to NETWAYS GmbH.)
#
# By intentionally submitting any modifications, corrections or
# derivatives to this work, or any other work intended for use with
# this Software, to NETWAYS GmbH, you confirm that
# you are the copyright holder for those contributions and you grant
# NETWAYS GmbH a nonexclusive, worldwide, irrevocable,
# royalty-free, perpetual, license to use, copy, create derivative
# works based on those contributions, and sublicense and distribute
# those contributions and any derivatives thereof.
#
# Nagios and the Nagios logo are registered trademarks of Ethan Galstad.

sub genTimeperiods {
    my $CONFIG = shift;
    my $target = shift;
    my $dir    = shift;
    my $outputDir;

    # set output dir
    if (defined $dir) { $outputDir = $dir; } else { $outputDir = $opt->{outputDir}; }

    # get all timeperiods
    my $TIMEPERIODS = HashGrep($CONFIG, 'objectclass', $cfg->{ldap}->{prefix}.'Timeperiod');

    # check all timeperiods... are they below $cfg->{ldap}->{baseDN} ?
    # --> so timeperiod objects in ou=Examples and ou=Templates will not be handled
    foreach my $val (keys %{$TIMEPERIODS}) { delete $TIMEPERIODS->{$val} if $val !~ /$cfg->{ldap}->{baseDN}$/; }

    # a special target is set?
    if (defined($target)) { foreach my $val (keys %{$TIMEPERIODS}) { delete $TIMEPERIODS->{$val} if $val !~ /$target$/; } }

    foreach my $timeperiod (keys %{$TIMEPERIODS}) {
        # get target file's name and open it for writing
        my $writeFile = BuildFilepath($TIMEPERIODS->{$timeperiod}->{dn}, $outputDir);
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

        print FH "define timeperiod {\n";
        foreach (sort keys %{$TIMEPERIODS->{$timeperiod}}) {
            if ($itemMap{$_} || $_ eq "$cfg->{ldap}->{prefix}timeperiodvalue") {
                if ($_ eq 'cn') {
                    print FH "\ttimeperiod_name\t$TIMEPERIODS->{$timeperiod}->{$_}\n";
                } elsif ($_ eq "$cfg->{ldap}->{prefix}timeperiodvalue") {
                    foreach my $val (sort keys %{$TIMEPERIODS->{$timeperiod}->{$_}}) {
                        foreach my $timeperiod_value (sort keys %{$TIMEPERIODS->{$timeperiod}->{$_}->{$val}}) {
                            print FH "\t$timeperiod_value\t$TIMEPERIODS->{$timeperiod}->{$_}->{$val}->{$timeperiod_value}\n";
                        }
                    }
                } else {
                    print FH "\t$itemMap{$_}\t$TIMEPERIODS->{$timeperiod}->{$_}\n";
                }
            }
        }
        print FH "}\n";

        # close target file
        close(FH);
    }
}

sub genCommands {
    my $CONFIG = shift;
    my $target = shift;
    my $dir    = shift;
    my $outputDir;

    # set output dir
    if (defined $dir) { $outputDir = $dir; } else { $outputDir = $opt->{outputDir}; }

    # get all commands
    my $COMMANDS = HashGrep($CONFIG, 'objectclass', $cfg->{ldap}->{prefix}.'Command');

    # check all commands... are they below $cfg->{ldap}->{baseDN} ?
    # --> so command objects in ou=Examples and ou=Templates will not be handled
    foreach my $val (keys %{$COMMANDS}) { delete $COMMANDS->{$val} if $val !~ /$cfg->{ldap}->{baseDN}$/; }

    # a special target is set?
    if (defined($target)) { foreach my $val (keys %{$COMMANDS}) { delete $COMMANDS->{$val} if $val !~ /$target$/; } }

    foreach my $command (keys %{$COMMANDS}) {
        # get target file's name and open it for writing
        my $writeFile = BuildFilepath($COMMANDS->{$command}->{dn}, $outputDir);
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

        print FH "define command {\n";
        foreach (sort keys %{$COMMANDS->{$command}}) {
            if ($itemMap{$_}) {
                if ($_ eq 'cn') {
                    print FH "\tcommand_name\t $COMMANDS->{$command}->{$_}\n";
                } else {
                    print FH "\t$itemMap{$_}\t $COMMANDS->{$command}->{$_}\n";
                }
            }
        }
        print FH "}\n";

        # close target file
        close(FH);
    }
}

sub genContacts {
    my $CONFIG = shift;
    my $target = shift;
    my $dir    = shift;
    my $outputDir;

    # set output dir
    if (defined $dir) { $outputDir = $dir; } else { $outputDir = $opt->{outputDir}; }

    # get all contacts
    my $CONTACTS = HashGrep($CONFIG, 'objectclass', $cfg->{ldap}->{prefix}.'Contact$');

    # check all contacts... are they below $cfg->{ldap}->{baseDN} ?
    # --> so contact objects in ou=Examples and ou=Templates will not be handled
    foreach my $val (keys %{$CONTACTS}) { delete $CONTACTS->{$val} if $val !~ /$cfg->{ldap}->{baseDN}$/; }

    # a special target is set?
    if (defined($target)) { foreach my $val (keys %{$CONTACTS}) { delete $CONTACTS->{$val} if $val !~ /$target$/; } }

    foreach my $contact (keys %{$CONTACTS}) {
        # get target file's name and open it for writing
        my $writeFile = BuildFilepath($CONTACTS->{$contact}->{dn}, $outputDir);
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

        print FH "define contact {\n";
        print FH "\tuse generic-contact\n";
        foreach(sort keys %{$CONTACTS->{$contact}}) {
            if ($itemMap{$_}) {
                if ($_ eq 'cn') {
                    print FH "\tcontact_name\t$CONTACTS->{$contact}->{$_}\n";
                } else {
                    print FH "\t$itemMap{$_}\t$CONTACTS->{$contact}->{$_}\n";
                }
            }
        }
        print FH "}\n";

        # close target file
        close(FH);

    }
}

sub genContactgroups {
    my $CONFIG = shift;
    my $target = shift;
    my $dir    = shift;
    my $outputDir;

    # set output dir
    if (defined $dir) { $outputDir = $dir; } else { $outputDir = $opt->{outputDir}; }

    # get all contactgroups
    my $CONTACTGROUPS = HashGrep($CONFIG, 'objectclass', $cfg->{ldap}->{prefix}.'Contactgroup');

    # check all contactgroups... are they below $cfg->{ldap}->{baseDN} ?
    # --> so contactgroup objects in ou=Examples and ou=Templates will not be handled
    foreach my $val (keys %{$CONTACTGROUPS}) { delete $CONTACTGROUPS->{$val} if $val !~ /$cfg->{ldap}->{baseDN}$/; }

    # a special target is set?
    if (defined($target)) { foreach my $val (keys %{$CONTACTGROUPS}) { delete $CONTACTGROUPS->{$val} if $val !~ /$target$/; } }

    foreach my $contactgroup (keys %{$CONTACTGROUPS}) {
        # get target file's name and open it for writing
        my $writeFile = BuildFilepath($CONTACTGROUPS->{$contactgroup}->{dn}, $outputDir);
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

        print FH "define contactgroup {\n";
        foreach (sort keys %{$CONTACTGROUPS->{$contactgroup}}) {
            if ($itemMap{$_}) {
                if ($_ eq 'cn') {
                    print FH "\tcontactgroup_name\t$CONTACTGROUPS->{$contactgroup}->{$_}\n";
                } else {
                    print FH "\t$itemMap{$_}\t$CONTACTGROUPS->{$contactgroup}->{$_}\n";
                }
            }
        }
        print FH "}\n";

        # close target file
        close(FH);
    }
}

sub genHostgroups {
    my $CONFIG  = shift;
    my $CLIENTS = shift;
    my $target  = shift;
    my $dir    = shift;
    my $outputDir;

    # set output dir
    if (defined $dir) { $outputDir = $dir; } else { $outputDir = $opt->{outputDir}; }

    # get all hostgroups defined by hostgroup object
    my $result = HashGrep($CONFIG, 'objectclass', $cfg->{ldap}->{prefix}.'Hostgroup');

    # check all hostgroups... are they below $cfg->{ldap}->{baseDN} ?
    # --> so hostgroups objects in ou=Examples and ou=Templates will not be handled
    foreach my $val (keys %{$result}) { delete $result->{$val} if $val !~ /$cfg->{ldap}->{baseDN}$/; }

    # a special target is set?
    if (defined($target)) { foreach my $val (keys %{$result}) { delete $result->{$val} if $val !~ /$target$/; } }

    # process hostgroups by hostgroup object
    foreach my $hostgroup (keys %{$result}) {
        # if there are 'member'-attributes, push the values to $CLIENT hash
        if (defined $result->{$hostgroup}->{$cfg->{ldap}->{prefix}.'members'}) {
            # multiple values? split...
            my @hosts = split(/\,/, $result->{$hostgroup}->{$cfg->{ldap}->{prefix}.'members'});
            foreach my $host (@hosts) {
                # find the right host
                my $tmp_hash = HashGrep($CLIENTS, 'objectclass', $cfg->{ldap}->{prefix}.'Host');
                my $hostsearch = HashGrep($tmp_hash, 'dn', '^cn='.$host.',');
                foreach my $val1 (keys %{$hostsearch}) {
                    if (defined $CLIENTS->{$val1}->{$cfg->{ldap}->{prefix}.'hostgroups'}) {
                        $CLIENTS->{$val1}->{$cfg->{ldap}->{prefix}.'hostgroups'} .= ','.$result->{$hostgroup}->{cn};
                    } else {
                        $CLIENTS->{$val1}->{$cfg->{ldap}->{prefix}.'hostgroups'} .= $result->{$hostgroup}->{cn};
                    }
                }
            }
        }

        # Search for escalations below of a hostgroupgroup
        my $he_result = HashGrep($CONFIG, 'dn', '^[\w]+=[._\w\/\d\s:-]+,'.$hostgroup);
        my $HOSTESCALATIONS = HashGrep($he_result, 'objectclass', $cfg->{ldap}->{prefix}.'hostescalation$');
        foreach my $escalation (keys %{$HOSTESCALATIONS}) {
            my $writeFile = $outputDir."/hostescalations/$he_result->{$escalation}->{cn}.cfg";

            # open target file
            open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";
            print FH "define hostescalation {\n";
            print FH "\t$itemMap{lconfhostescalationhostgroups}\t$CONFIG->{$hostgroup}->{cn}\n";

            foreach my $val1 (sort keys %{$he_result->{$escalation}}) {
                if ($val1 =~ /$cfg->{ldap}->{prefix}hostescalation/) {
                    print FH "\t$itemMap{$val1}\t$he_result->{$escalation}->{$val1}\n";
                }
            }
            print FH "}\n\n";

            # close target file
            close(FH);
        }

    }

    # get all hostgroups defined by hostobject
    foreach my $client (keys %{$CLIENTS}) {
        if (defined $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostgroups"}) {
            # multiple or a single hostgroup?
            if ($CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostgroups"} =~ /,/) {
                my @val = split(/\s*,\s*/, $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostgroups"});
                foreach(@val) { $result->{$_}->{cn} = $_ if $_ ne ''; }
            } else {
                $result->{$CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostgroups"}}->{cn} = $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostgroups"};
            }

            # look for host's hostgroups and their services (seperated logic)
            my @hhgs = split(/\s*,\s*/, $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostgroups"});
            foreach my $hg (@hhgs) {
                # find the right hostgroup
                my $hostgroup = HashGrep($result, 'dn', '^cn='.$hg.',');
                # only one, but we'll get a hash anyways
                foreach my $hostgroupdn (keys %{$hostgroup}) {
                    DebugOutput("GENERATE HOSTGROUPCONFIG", "Generate host services for hostgroup '$hg'", 1);
                    # look for services below hostgroup
                    my $hg_result = HashGrep($CONFIG, 'dn', '^[\w]+=[._\w\/\d\s:-]+,'.$hostgroupdn);
                    my $HOSTGROUPSERVICES = HashGrep($hg_result, 'objectclass', $cfg->{ldap}->{prefix}.'Service$');
                    foreach my $service (keys %{$HOSTGROUPSERVICES}) {
                        DebugOutput("GENERATE HOSTGROUPCONFIG", " HostDN: '$client'", 1);
                        DebugOutput("GENERATE HOSTGROUPCONFIG", " ServiceDN: '$service'", 1);
                        # we'll override all host SERVICES if there are duplicates
                        # clone the hash to prevent wrong references on dumping host services
                        $CLIENTS->{$client}->{SERVICES}->{$HOSTGROUPSERVICES->{$service}->{'cn'}} = dclone($HOSTGROUPSERVICES->{$service});
                    }
                }

            }
        }
    }

    # write hostgroup files
    foreach my $hostgroup (keys %{$result}) {
        # set file path
        my $writeFile = $outputDir."/hostgroups/$result->{$hostgroup}->{cn}.cfg";

        # open target file
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";
        print FH "define hostgroup {\n";
        print FH "\thostgroup_name\t$result->{$hostgroup}->{cn}\n";
        if (defined $result->{$hostgroup}->{$cfg->{ldap}->{prefix}.'alias'}) {
            print FH "\talias\t$result->{$hostgroup}->{$cfg->{ldap}->{prefix}.'alias'}\n";
        } else {
            print FH "\talias\t$result->{$hostgroup}->{cn}\n";
        }
        print FH "}\n";

        # close target file
        close(FH);
    }
}

sub genServicegroups {
    my $CONFIG  = shift;
    my $CLIENTS = shift;
    my $target  = shift;
    my $dir     = shift;
    my $outputDir;

    # set output dir
    if (defined $dir) { $outputDir = $dir; } else { $outputDir = $opt->{outputDir}; }

    # get all hostgroups defined by hostgroup object
    my $result = HashGrep($CONFIG, 'objectclass', $cfg->{ldap}->{prefix}.'Servicegroup');

    # check all servicegroups... are they below $cfg->{ldap}->{baseDN} ?
    # --> so servicegroups objects in ou=Examples and ou=Templates will not be handled
    foreach my $val (keys %{$result}) { delete $result->{$val} if $val !~ /$cfg->{ldap}->{baseDN}$/; }

    # a special target is set?
    if (defined($target)) { foreach my $val (keys %{$result}) { delete $result->{$val} if $val !~ /$target$/; } }

    # process servicegroups
    foreach my $servicegroup (keys %{$result}) {
        # if there are 'member'-attributes, push the values to $CLIENT hash
        if (defined $result->{$servicegroup}->{$cfg->{ldap}->{prefix}.'members'}) {
            my @val = split(/\s*,\s*/, $result->{$servicegroup}->{"$cfg->{ldap}->{prefix}members"});
            my $counter = 0;

            while($counter <= $#val) {
                # search full name im client hash :(
                foreach my $client (keys %{$CLIENTS}) {
                    # if real name was found, add to $CLIENT hash
                    if ($client =~ /^cn=$val[$counter],/) {
                        if ($CLIENTS->{$client}->{SERVICES}->{$val[$counter+1]}->{"$cfg->{ldap}->{prefix}servicegroups"}) {
                            $CLIENTS->{$client}->{SERVICES}->{$val[$counter+1]}->{"$cfg->{ldap}->{prefix}servicegroups"} = $CLIENTS->{$client}->{SERVICES}->{$val[$counter+1]}->{"$cfg->{ldap}->{prefix}servicegroups"}.','.$result->{$servicegroup}->{'cn'};
                        } else {
                            $CLIENTS->{$client}->{SERVICES}->{$val[$counter+1]}->{"$cfg->{ldap}->{prefix}servicegroups"} = $result->{$servicegroup}->{'cn'};
                        }
                    }
                }

                $counter = $counter+2;
            }
        }

        # Search for escalations below of a servicegroup
        my $se_result = HashGrep($CONFIG, 'dn', '^[\w]+=[._\w\/\d\s:-]+,'.$servicegroup);
        my $SERVICEESCALATIONS = HashGrep($se_result, 'objectclass', $cfg->{ldap}->{prefix}.'serviceescalation$');

        foreach my $escalation (keys %{$SERVICEESCALATIONS}) {
            my $writeFile = $outputDir."/serviceescalations/$se_result->{$escalation}->{cn}.cfg";

            # open target file
            open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";
            print FH "define serviceescalation {\n";
            print FH "\t$itemMap{lconfserviceescalationservicegroups}\t$CONFIG->{$servicegroup}->{cn}\n";

            foreach my $val1 (sort keys %{$se_result->{$escalation}}) {
                if ($val1 =~ /$cfg->{ldap}->{prefix}serviceescalation/) {
                    print FH "\t$itemMap{$val1}\t$se_result->{$escalation}->{$val1}\n";
                }
            }
            print FH "}\n\n";

            # close target file
            close(FH);
        }
      }

    # get all servicegroups defined by serviceobject
    foreach my $client (keys %{$CLIENTS}) {
        foreach my $service (keys %{$CLIENTS->{$client}->{SERVICES}}) {
            if (defined $CLIENTS->{$client}->{SERVICES}->{$service}->{"$cfg->{ldap}->{prefix}servicegroups"}) {
                # multiple or a single servicegroup?
                if ($CLIENTS->{$client}->{SERVICES}->{$service}->{"$cfg->{ldap}->{prefix}servicegroups"} =~ /,/) {
                    my @val = split(/\s*,\s*/, $CLIENTS->{$client}->{SERVICES}->{$service}->{"$cfg->{ldap}->{prefix}servicegroups"});
                    foreach(@val) { $result->{$_}->{cn} = $_ if $_ ne ''; }
                } else {
                    $result->{$CLIENTS->{$client}->{SERVICES}->{$service}->{"$cfg->{ldap}->{prefix}servicegroups"}}->{cn} = $CLIENTS->{$client}->{SERVICES}->{$service}->{"$cfg->{ldap}->{prefix}servicegroups"};
                }
            }
        }
    }

    # write servicegroup files
    foreach my $servicegroup (keys %{$result}) {
        # set file path
        my $writeFile = $outputDir."/servicegroups/$result->{$servicegroup}->{cn}.cfg";

        # open target file
        open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";
        print FH "define servicegroup {\n";
        print FH "\tservicegroup_name\t$result->{$servicegroup}->{cn}\n";
        if (defined $result->{$servicegroup}->{$cfg->{ldap}->{prefix}.'alias'}) {
            print FH "\talias\t$result->{$servicegroup}->{$cfg->{ldap}->{prefix}.'alias'}\n";
        } else {
            print FH "\talias\t$result->{$servicegroup}->{cn}\n";
        }
        print FH "}\n";

        # close target file
        close(FH);
    }
}

sub genHostConfig {
    my $CLIENTS = shift;
    my $client = shift;
    my $dir    = shift;
    my $outputDir;

    # set output dir
    if (defined $dir) { $outputDir = $dir; } else { $outputDir = $opt->{outputDir}; }

    DebugOutput("$$ GENERATE HOSTCONFIG", "Generate config for $client", 1);
    if (defined $CLIENTS->{$client}->{dn}) {
        # only gen config if lconfhostdisable is not set
        if (!defined $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostdisable"}) {
            #
            # HOST DEFINITION
            #
                # get target file's name and open it for writing
                my $writeFile = BuildFilepath($CLIENTS->{$client}->{dn}, $outputDir);
                open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

                # generate host definition
                print FH "define host {\n";
                print FH "\tuse generic-host\n";
                print FH "\thost_name\t$CLIENTS->{$client}->{cn}\n";

                # process each item...
                foreach my $val1 (sort keys %{$CLIENTS->{$client}}) {
                    # ...but look after type; only host items
                    # and no service dependency attributes;
                    # they will be handled in an other way
                    if (($val1 =~ /$cfg->{ldap}->{prefix}host/ || $val1 eq "$cfg->{ldap}->{prefix}address" || $val1 eq "$cfg->{ldap}->{prefix}parent" || $val1 eq "$cfg->{ldap}->{prefix}alias") && $val1 !~ /$cfg->{ldap}->{prefix}hostdependency/) {
                        # customvar or a default item?
                        if ($val1 =~ /customvar/i) {
                            foreach my $val2 (sort keys %{$CLIENTS->{$client}->{$val1}}) {
                                print FH "\t$val2\t$CLIENTS->{$client}->{$val1}->{$val2}\n";
                            }
                        } else {
                            print FH "\t$itemMap{$val1}\t$CLIENTS->{$client}->{$val1}\n";
                        }
                    }
                }

                # generate end of host definition
                print FH "}\n";
                print FH "\n";

            #
            # SERVICES
            #
            foreach my $service (keys %{$CLIENTS->{$client}->{'SERVICES'}}) {
                DebugOutput("$$ GENERATE HOSTCONFIG", "Found service $service", 1);
                # only gen service if lconfservicedisable is not set
                if (!defined $CLIENTS->{$client}->{'SERVICES'}->{$service}->{"$cfg->{ldap}->{prefix}servicedisable"}) {
                    print FH "define service {\n";
                    print FH "\tuse generic-service\n";
                    print FH "\tservice_description\t$CLIENTS->{$client}->{'SERVICES'}->{$service}->{cn}\n";
                    print FH "\thost_name\t$CLIENTS->{$client}->{cn}\n";

                    # process each item
                    foreach my $val1 (sort keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}}) {
                        # ...but look after type; only service items!
                        if (($val1 =~ /$cfg->{ldap}->{prefix}service/ || $val1 eq "$cfg->{ldap}->{prefix}checkcommand") && $val1 !~ /$cfg->{ldap}->{prefix}servicedependency/) {
                            # customvar or a default item?
                            if ($val1 =~ /customvar/i) {
                                foreach my $val2 (sort keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}}) {
                                    next if (!$CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}->{$val2}); # XXX find a better way to handle empty customvars before
                                    print FH "\t$val2\t$CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}->{$val2}\n";
                                }
                            } else {
                                print FH "\t$itemMap{$val1}\t$CLIENTS->{$client}->{'SERVICES'}->{$service}->{$val1}\n";
                            }
                        }
                    }

                    print FH "}\n";
                    print FH "\n";
                }
            }

            #
            # HOST DEPENDENCIES
            #
            foreach my $dependency (sort keys %{$CLIENTS->{$client}->{'DEPENDENCY'}}) {
                # only if host is not disabled
                if (!$CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostdisable"}) {
                    print FH "define hostdependency {\n";
                    print FH "\thost_name\t$dependency\n";
                    print FH "\tdependent_host_name\t$CLIENTS->{$client}->{cn}\n";
                    foreach(sort keys %{$CLIENTS->{$client}->{DEPENDENCY}->{$dependency}}) {
                        print FH "\t$itemMap{$_}\t$CLIENTS->{$client}->{DEPENDENCY}->{$dependency}->{$_}\n" if $itemMap{$_};
                    }
                    print FH "}\n";
                    print FH "\n";
                }
            }

            #
            # SERVICE DEPENDENCIES
            #
            foreach my $service (sort keys %{$CLIENTS->{$client}->{'SERVICES'}}) {
                # only gen service if lconfservicedisable is not set
                if (!defined $CLIENTS->{$client}->{'SERVICES'}->{$service}->{"$cfg->{ldap}->{prefix}servicedisable"}) {
                    if (defined $CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEDEPENDENCY}) {
                        foreach my $dependency (sort keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEDEPENDENCY}}) {
                            my ($depHost, $depService) = (split(/ *-> */, $dependency))[0,1];

                            print FH "define servicedependency {\n";

                            # special stuff for inheritance :-(
                            if ($depHost eq "\$HOSTNAME\$") {
                                print FH "\thost_name\t$CLIENTS->{$client}->{cn}\n";
                            } else {
                                print FH "\thost_name\t$depHost\n";
                            }

                            print FH "\tservice_description\t$depService\n";
                            print FH "\tdependent_host_name\t$CLIENTS->{$client}->{cn}\n";
                            print FH "\tdependent_service_description\t$service\n";
                            foreach (sort keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEDEPENDENCY}->{$dependency}}) {
                                print FH "\t$itemMap{$_}\t$CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEDEPENDENCY}->{$dependency}->{$_}\n";
                            }
                            print FH "}\n";
                            print FH "\n";
                        }
                    }
                }
            }

            #
            # HOST ESCALATIONS
            #
            foreach my $escalation (sort keys %{$CLIENTS->{$client}->{'HOSTESCALATION'}}) {
                # only if host is not disabled
                if (!$CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostdisable"}) {
                    print FH "define hostescalation {\n";
                    print FH "\thost_name\t$CLIENTS->{$client}->{cn}\n";
                    foreach my $val (keys %{$CLIENTS->{$client}->{HOSTESCALATION}->{$escalation}}) {
                        print FH "\t$itemMap{$val}\t$CLIENTS->{$client}->{HOSTESCALATION}->{$escalation}->{$val}\n";
                    }
                    print FH "}\n";
                    print FH "\n";
                }
            }

            #
            # SERVICE ESCALATIONS
            #
            foreach my $service (sort keys %{$CLIENTS->{$client}->{'SERVICES'}}) {
                # only gen service if lconfservicedisable is not set
                if (!defined $CLIENTS->{$client}->{'SERVICES'}->{$service}->{"$cfg->{ldap}->{prefix}servicedisable"}) {
                    if (defined $CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEESCALATION}) {
                        foreach my $escalation (sort keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEESCALATION}}) {
                            print FH "define serviceescalation {\n";
                            print FH "\thost_name\t$CLIENTS->{$client}->{cn}\n";
                            print FH "\tservice_description\t$service\n";
                            foreach my $val (keys %{$CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEESCALATION}->{$escalation}}) {
                                print FH "\t$itemMap{$val}\t$CLIENTS->{$client}->{'SERVICES'}->{$service}->{SERVICEESCALATION}->{$escalation}->{$val}\n";
                            }
                            print FH "}\n";
                            print FH "\n";
                        }
                    }
                }
            }
        }
    }
}

1;

# vi: sw=4 ts=4 expandtab :

