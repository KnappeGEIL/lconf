sub genTimeperiods {
	my $searchTarget = shift;
	$searchTarget = $cfg->{ldap}->{baseDN} if !defined $searchTarget;
	
	# get all timeperiods
	my $result = LDAPsearch($ldap, $searchTarget, "sub", "objectclass=$cfg->{ldap}->{prefix}Timeperiod");
	foreach my $timeperiod (keys %{$result}) {
		# build file path
		my $writeFile = $opt->{outputDir}.'/';
		my $path = $result->{$timeperiod}->{dn};
		$path =~ s/,$cfg->{ldap}->{baseDN}//;
		my @path = split(",", $path);
		@path = reverse(@path);
		foreach my $items (@path) {
			# file or folder?
			if ($items =~ /cn/) {
				my $val = (split(/\=/, $items))[1];
				$writeFile .= $val.'.cfg';
			} else {
				my $val = (split(/\=/, $items))[1];
				$writeFile .= $val.'/';
			}
		}

		# open target file
		open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

		print FH "define timeperiod {\n";
		foreach (keys %{$result->{$timeperiod}}) {
			if ($itemMap{$_} || $_ eq "$cfg->{ldap}->{prefix}timeperiodvalue") {
				if ($_ eq 'cn') {
					print FH "\ttimeperiod_name\t$result->{$timeperiod}->{$_}\n";
				} elsif ($_ eq "$cfg->{ldap}->{prefix}timeperiodvalue") {
					foreach my $val (keys %{$result->{$timeperiod}->{$_}}) {
						foreach my $timeperiod_value (keys %{$result->{$timeperiod}->{$_}->{$val}}) {
							print FH "\t$timeperiod_value\t$result->{$timeperiod}->{$_}->{$val}->{$timeperiod_value}\n";
						}
					}
				} else {
					print FH "\t$itemMap{$_}\t$result->{$timeperiod}->{$_}\n";
				}
			}
		}
		print FH "}\n";

		# close target file
		close(FH);
	}
}

sub genCommands {
	my $searchTarget = shift;
	$searchTarget = $cfg->{ldap}->{baseDN} if !defined $searchTarget;
	
	# get all commands
	my $result = LDAPsearch($ldap, $searchTarget, "sub", "objectclass=$cfg->{ldap}->{prefix}Command");
	foreach my $command (keys %{$result}) {
	# build file path
	my $writeFile = $opt->{outputDir}.'/';
	my $path = $result->{$command}->{dn};
	$path =~ s/,$cfg->{ldap}->{baseDN}//;
	my @path = split(",", $path);
	@path = reverse(@path);
	foreach my $items (@path) {
		# file or folder?
		if ($items =~ /cn/) {
			my $val = (split(/\=/, $items))[1];
			$writeFile .= $val.'.cfg';
		} else {
			my $val = (split(/\=/, $items))[1];
			$writeFile .= $val.'/';
		}
	}

	# open target file
	open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

	print FH "define command {\n";
	foreach (keys %{$result->{$command}}) {
		if ($itemMap{$_}) {
			if ($_ eq 'cn') {
				print FH "\tcommand_name\t$result->{$command}->{$_}\n";
			} else {
				print FH "\t$itemMap{$_}\t$result->{$command}->{$_}\n";
			}
		}
	}
	print FH "}\n";

	# close target file
	close(FH);
	}
}

sub genContacts {
	my $searchTarget = shift;
	$searchTarget = $cfg->{ldap}->{baseDN} if !defined $searchTarget;
	
	# get all contacts
	my $result = LDAPsearch($ldap, $searchTarget, "sub", "objectclass=$cfg->{ldap}->{prefix}Contact");
	foreach my $contact (keys %{$result}) {
		# build file path
		my $writeFile = $opt->{outputDir}.'/';
		my $path = $result->{$contact}->{dn};
		$path =~ s/,$cfg->{ldap}->{baseDN}//;
		my @path = split(",", $path);
		@path = reverse(@path);
		foreach my $items (@path) {
			# file or folder?
			if ($items =~ /cn/) {
				my $val = (split(/\=/, $items))[1];
				$writeFile .= $val.'.cfg';
			} else {
				my $val = (split(/\=/, $items))[1];
				$writeFile .= $val.'/';
			}
		}

		# open target file
		open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

		print FH "define contact {\n";
		print FH "\tuse generic-contact\n";
		foreach(keys %{$result->{$contact}}) {
			if ($itemMap{$_}) {
				if ($_ eq 'cn') {
					print FH "\tcontact_name\t$result->{$contact}->{$_}\n";
				} else {
					print FH "\t$itemMap{$_}\t$result->{$contact}->{$_}\n";
				}
			}
		}
		print FH "}\n";

		# close target file
		close(FH);
	}
}

sub genContactgroups {
	my $searchTarget = shift;
	$searchTarget = $cfg->{ldap}->{baseDN} if !defined $searchTarget;
	
	# get all contactgroups
	my $result = LDAPsearch($ldap, $searchTarget, "sub", "objectclass=$cfg->{ldap}->{prefix}Contactgroup");
	foreach my $contactgroup (keys %{$result}) {
		# build file path
		my $writeFile = $opt->{outputDir}.'/';
		my $path = $result->{$contactgroup}->{dn};
		$path =~ s/,$cfg->{ldap}->{baseDN}//;
		my @path = split(",", $path);
		@path = reverse(@path);
		foreach my $items (@path) {
			# file or folder?
			if ($items =~ /cn/) {
				my $val = (split(/\=/, $items))[1];
				$writeFile .= $val.'.cfg';
			} else {
				my $val = (split(/\=/, $items))[1];
				$writeFile .= $val.'/';
			}
		}

		# open target file
		open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

		print FH "define contactgroup {\n";
		foreach (keys %{$result->{$contactgroup}}) {
			if ($itemMap{$_}) {
				if ($_ eq 'cn') {
					print FH "\tcontactgroup_name\t$result->{$contactgroup}->{$_}\n";
				} else {
					print FH "\t$itemMap{$_}\t$result->{$contactgroup}->{$_}\n";
				}
			}
		}
		print FH "}\n";

		# close target file
		close(FH);
	}
}

sub genHostgroups {
	my $searchTarget = shift;
	$searchTarget = $cfg->{ldap}->{baseDN} if !defined $searchTarget;
	
	my @HOSTGROUPS;

	# get hostgroups (from client attributes)
	foreach my $client (keys %{$CLIENTS}) {
		if (defined $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostgroups"}) {
			if ($CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostgroups"} =~ /,/) {
				my @val = split(/\s*,\s*/, $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostgroups"});
				foreach(@val) { push(@HOSTGROUPS, $_); }
			} else {
				push(@HOSTGROUPS, $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostgroups"});
			}
		}
	}

	# write hostgroup files
	foreach my $hostgroup (@HOSTGROUPS) {
		# set file path
		my $writeFile = $opt->{outputDir}."/hostgroups/$hostgroup.cfg";

		# open target file
		open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";
		print FH "define hostgroup {\n";
		print FH "\thostgroup_name\t$hostgroup\n";
		print FH "\talias\t$hostgroup\n";
		print FH "}\n";

        # close target file
        close(FH);
	}
        
	# get hostgroups (from objectclass 'lconfHostgroup') and write files
	my $result = LDAPsearch($ldap, $searchTarget, "sub", "objectclass=$cfg->{ldap}->{prefix}Hostgroup");
	foreach my $val1 (keys %{$result}) {
		# set file path
		my $writeFile = $opt->{outputDir}."/hostgroups/$result->{$val1}->{cn}.cfg";

		# open target file
		open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

		print FH "define hostgroup {\n";
		print FH "\thostgroup_name\t$result->{$val1}->{cn}\n";
		print FH "\talias\t$result->{$val1}->{lconfalias}\n";
		print FH "}\n";

		# close target file
		close(FH);

		# add hosts of this hostgroup to $CLIENT hash;
		# client config will write the config for membership
		if (defined $result->{$val1}->{"$cfg->{ldap}->{prefix}members"}) {
			my @val = split(/\s*,\s*/, $result->{$val1}->{"$cfg->{ldap}->{prefix}members"});
			foreach(@val) {
				# search full name im client hash :(
				foreach my $client (keys %{$CLIENTS}) {
					# if real name was found, add to $CLIENT hash
					if ($client =~ /^cn=$_,/) {
						if ($CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostgroups"}) {
							$CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostgroups"} =  $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostgroups"}.','.$result->{$val1}->{cn};
						} else {
							$CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostgroups"} = $result->{$val1}->{cn};
						}
					}
				}
			}
		}
	}
}

sub HostgroupServiceMapping {
	my $searchTarget = shift;
	$searchTarget = $cfg->{ldap}->{baseDN} if !defined $searchTarget;
	
	# search for each host :(
	foreach my $client (keys %{$CLIENTS}) {
		# any hostgroup for this host?
		if ($CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostgroups"}) {
			my @hostgroups = split(/\s*,\s*/, $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostgroups"});

			# search after hostgroup (objectclass)
			foreach my $hostgroup (@hostgroups) {
				my $result = LDAPsearch($ldap, $searchTarget, 'sub', "(&(objectclass=$cfg->{ldap}->{prefix}Hostgroup)(cn=$hostgroup))");

				# search stuff in hostgroup dn
				foreach my $val (keys %{$result}) {
					# cut client's dn
					$client =~ s/,$searchTarget//;

					# search services
					my $result2 = LDAPsearch($ldap, $result->{$val}->{dn}, 'sub', "objectclass=$cfg->{ldap}->{prefix}Service");
					$CLIENTS = addServices($result2, $client, $CLIENTS, $result->{$val}->{dn});
				}
			}
		}
	}
}

sub genServicegroups {
	my $searchTarget = shift;
	$searchTarget = $cfg->{ldap}->{baseDN} if !defined $searchTarget;
	
	my @SERVICEGROUPS;

	# get servicegroups (from client attributes)
	foreach my $client (keys %{$CLIENTS}) {
		for my $service (keys %{$CLIENTS->{$client}->{SERVICES}}) {
			if (defined $CLIENTS->{$client}->{SERVICES}->{$service}->{"$cfg->{ldap}->{prefix}servicegroups"}) {
				if ($CLIENTS->{$client}->{SERVICES}->{$service}->{"$cfg->{ldap}->{prefix}servicegroups"} =~ /,/) {
					my @val = split(/\s*,\s*/, $CLIENTS->{$client}->{SERVICES}->{$service}->{"$cfg->{ldap}->{prefix}servicegroups"});
					foreach(@val) { push(@SERVICEGROUPS, $_); }
				} else {
					push(@SERVICEGROUPS, $CLIENTS->{$client}->{SERVICES}->{$service}->{"$cfg->{ldap}->{prefix}servicegroups"});
				}
			}
		}
	}

	# write servicegroup files
	foreach my $servicegroup (@SERVICEGROUPS) {
		# set file path
		my $writeFile = $opt->{outputDir}."/servicegroups/$servicegroup.cfg";

		# open target file
		open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

		print FH "define servicegroup {\n";
		print FH "\tservicegroup_name\t$servicegroup\n";
		print FH "\talias\t$servicegroup\n";
		print FH "}\n";

		# close target file
		close(FH);
	}
        
	# get servicegroups (from objectclass 'lconfServicegroup') and write files
	my $result = LDAPsearch($ldap, $searchTarget, "sub", "objectclass=$cfg->{ldap}->{prefix}Servicegroup");
	foreach my $val1 (keys %{$result}) {
		# set file path
		my $writeFile = $opt->{outputDir}."/servicegroups/$result->{$val1}->{cn}.cfg";

		# open target file
		open(FH, ">$writeFile") || die "Can't write data: $writeFile $!\n";

		print FH "define servicegroup {\n";
		print FH "\tservicegroup_name\t$result->{$val1}->{cn}\n";
		print FH "\talias\t$result->{$val1}->{cn}\n";
		print FH "}\n";

		# close target file
		close(FH);

		# add services of this servicegroup to $CLIENT hash
		# client config will write the config for membership
		if (defined $result->{$val1}->{"$cfg->{ldap}->{prefix}members"}) {
			my @val = split(/\s*,\s*/, $result->{$val1}->{"$cfg->{ldap}->{prefix}members"});
			my $counter = 0;
			while($counter <= $#val) {
				# search full name im client hash :(
				foreach my $client (keys %{$CLIENTS}) {
					# if real name was found, add to $CLIENT hash
					if ($client =~ /^cn=$val[$counter],/) {
						if ($CLIENTS->{$client}->{SERVICES}->{$val[$counter+1]}->{"$cfg->{ldap}->{prefix}servicegroups"}) {
							$CLIENTS->{$client}->{SERVICES}->{$val[$counter+1]}->{"$cfg->{ldap}->{prefix}servicegroups"} = $CLIENTS->{$client}->{SERVICES}->{$val[$counter+1]}->{"$cfg->{ldap}->{prefix}servicegroups"}.','.$result->{$val1}->{cn};
						} else {
							$CLIENTS->{$client}->{SERVICES}->{$val[$counter+1]}->{"$cfg->{ldap}->{prefix}servicegroups"} = $result->{$val1}->{cn};
						}
					}
				}

				$counter = $counter+2;
			}
		}
	}
}

sub genHostConfig {
	# do for each client
	foreach my $client (keys %{$CLIENTS}) {
		if (defined $CLIENTS->{$client}->{dn}) {
		my $host_name;

		# build file path
		my $writeFile = $opt->{outputDir}.'/';
		my $path = $CLIENTS->{$client}->{dn};
		$path =~ s/,$cfg->{ldap}->{baseDN}//;
		my @path = split(",", $path);
		@path = reverse(@path);
		foreach my $items (@path) {
			# file or folder?
			if ($items =~ /^cn/) {
				my $val = (split(/\=/, $items))[1];
				$writeFile .= $val.'.cfg';
				$host_name = $val;
			} else {
				my $val = (split(/\=/, $items))[1];
				$writeFile .= $val.'/';
			}
		}
                
		# only gen config if lconfhostdisable is not set
		if (!defined $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostdisable"}) {
			# open target file
			open(FH, ">$writeFile") || die "Can't write data: $writeFile: $!\n";

			# generate host definition
			print FH "define host {\n";

			# custom 'use' statement?
			print FH "\tuse\t";
			if (defined $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostcustomvar"}->{'_use'}) {
				print FH $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostcustomvar"}->{'_use'}.',';
				delete $CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostcustomvar"}->{'_use'};
			}
			print FH "generic-host\n";
	
			print FH "\thost_name\t$host_name\n";
			foreach (keys %{$CLIENTS->{$client}}) {
				# generate all host attributes, except host dependency stuff
				if ($_ !~ /$cfg->{ldap}->{prefix}hostdependency/ && $_ =~ /$cfg->{ldap}->{prefix}host/ || $_ eq "$cfg->{ldap}->{prefix}address" || $_ eq "$cfg->{ldap}->{prefix}parent" || $_ eq "$cfg->{ldap}->{prefix}alias" && $_ ne "$cfg->{ldap}->{prefix}hostdisable") {
					if ($_ eq "$cfg->{ldap}->{prefix}hostcustomvar") {
						foreach my $customvar (keys %{$CLIENTS->{$client}->{$_}}) {
							if (defined $INHERIT->{$client}->{$_}->{$customvar} && $INHERIT->{$client}->{$_}->{$customvar} ne $CLIENTS->{$client}->{dn}) {
								print FH "\t# from: $INHERIT->{$client}->{$_}->{$customvar}\n";
							}
							print FH "\t$customvar\t$CLIENTS->{$client}->{$_}->{$customvar}\n";
						}
					} else {
						if (defined $INHERIT->{$client}->{$_} && $INHERIT->{$client}->{$_} ne $CLIENTS->{$client}->{dn}) {
							print FH "\t# from: $INHERIT->{$client}->{$_}\n";
						}
						print FH "\t$itemMap{$_}\t$CLIENTS->{$client}->{$_}\n";
					}
				}
			}
			print FH "}\n";
			print FH "\n";
                        
			# generate service definition
			foreach my $service(keys %{$CLIENTS->{$client}->{SERVICES}}) {
				if (!$CLIENTS->{$client}->{SERVICES}->{$service}->{"$cfg->{ldap}->{prefix}servicedisable"} && $service ne "INFO") {
					if (defined $CLIENTS->{$client}->{SERVICES}->{$service}->{dn} && $CLIENTS->{$client}->{SERVICES}->{$service}->{dn} !~ /$CLIENTS->{$client}->{dn}/) {
						print FH "# from: $CLIENTS->{$client}->{SERVICES}->{$service}->{dn}\n";
					}
					print FH "define service {\n";
					
					# custom 'use' statement?
					print FH "\tuse\t";
					if (defined $CLIENTS->{$client}->{'SERVICES'}->{$service}->{"$cfg->{ldap}->{prefix}servicecustomvar"}->{'_use'}) {
						print FH $CLIENTS->{$client}->{'SERVICES'}->{$service}->{"$cfg->{ldap}->{prefix}servicecustomvar"}->{'_use'}.',';
						delete $CLIENTS->{$client}->{'SERVICES'}->{$service}->{"$cfg->{ldap}->{prefix}servicecustomvar"}->{'_use'};
					}
					print FH "generic-service\n";
				
					print FH "\tservice_description\t$service\n";
					print FH "\thost_name\t$host_name\n";
					foreach(keys %{$CLIENTS->{$client}->{SERVICES}->{$service}}) {
						# generate all service attributes, except service dependency stuff
						if ($_ !~ /$cfg->{ldap}->{prefix}servicedependency/ && $_ =~ /$cfg->{ldap}->{prefix}service/ || $_ eq "$cfg->{ldap}->{prefix}checkcommand") {
							if ($_ eq "$cfg->{ldap}->{prefix}servicecustomvar") {
								foreach my $customvar (keys %{$CLIENTS->{$client}->{SERVICES}->{$service}->{$_}}) {
									if (defined $INHERIT->{$client}->{SERVICES}->{$service}->{$_}->{$customvar} && $INHERIT->{$client}->{SERVICES}->{$service}->{$_}->{$customvar} ne $CLIENTS->{$client}->{SERVICES}->{$service}->{dn}) {
										print FH "\t# from: $INHERIT->{$client}->{SERVICES}->{$service}->{$_}->{$customvar}\n";
									}
									print FH "\t$customvar\t$CLIENTS->{$client}->{SERVICES}->{$service}->{$_}->{$customvar}\n";
								}
						} else {
							if (defined $INHERIT->{$client}->{SERVICES}->{$service}->{$_} && $INHERIT->{$client}->{SERVICES}->{$service}->{$_} ne $CLIENTS->{$client}->{SERVICES}->{$service}->{dn}) {
								print FH "\t# from: $INHERIT->{$client}->{SERVICES}->{$service}->{$_}\n";
							}
							print FH "\t$itemMap{$_}\t$CLIENTS->{$client}->{SERVICES}->{$service}->{$_}\n";
						}
					}
				}
				print FH "}\n";
				print FH "\n";
			}
		}
                        
		# generate host dependencies
		foreach my $hostdep(keys %{$CLIENTS->{$client}->{DEPENDENCY}}) {
			# only if host is not disabled
			if (!$CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostdisable"}) {
				print FH "define hostdependency {\n";
				print FH "\thost_name\t$hostdep\n";
				print FH "\tdependent_host_name\t$CLIENTS->{$client}->{cn}\n";
				foreach(keys %{$CLIENTS->{$client}->{DEPENDENCY}->{$hostdep}}) {
					print FH "\t$itemMap{$_}\t$CLIENTS->{$client}->{DEPENDENCY}->{$hostdep}->{$_}\n" if $itemMap{$_};
				}
				print FH "}\n";
				print FH "\n";
			}
		}
                        
		# generate service dependencies
		foreach my $service(keys %{$CLIENTS->{$client}->{SERVICES}}) {
			# only if service is not disabled
			if (!$CLIENTS->{$client}->{SERVICES}->{$service}->{"$cfg->{ldap}->{prefix}servicedisable"}) {
				foreach my $hostdep(keys %{$CLIENTS->{$client}->{SERVICES}->{$service}->{DEPENDENCY}}) {
					foreach my $servicedep(keys %{$CLIENTS->{$client}->{SERVICES}->{$service}->{DEPENDENCY}->{$hostdep}}) {
						print FH "define servicedependency {\n";
						# special stuff for inheritance :-(
						if ($hostdep eq "\$HOSTNAME\$") {
							print FH "\thost_name\t$CLIENTS->{$client}->{cn}\n";
						} else {
							print FH "\thost_name\t$hostdep\n";
						}

						print FH "\tservice_description\t$servicedep\n";
						print FH "\tdependent_host_name\t$CLIENTS->{$client}->{cn}\n";
						print FH "\tdependent_service_description\t$service\n";
						foreach(keys %{$CLIENTS->{$client}->{SERVICES}->{$service}->{DEPENDENCY}->{$hostdep}->{$servicedep}}) {
							print FH "\t$itemMap{$_}\t$CLIENTS->{$client}->{SERVICES}->{$service}->{DEPENDENCY}->{$hostdep}->{$servicedep}->{$_}\n";
						}
						print FH "}\n";
						print FH "\n";
					}
				}
			}
		}
		
		
		# generate hostescalations
		foreach my $hostesc (keys %{$CLIENTS->{$client}->{ESCALATIONS}}) {
			# only if host is not disabled
			if (!$CLIENTS->{$client}->{"$cfg->{ldap}->{prefix}hostdisable"}) {
				print FH "define hostescalation {\n";
				print FH "\thost_name\t$CLIENTS->{$client}->{cn}\n";
				foreach my $val (keys %{$CLIENTS->{$client}->{ESCALATIONS}->{$hostesc}}) {
					print FH "\t$itemMap{$val}\t$CLIENTS->{$client}->{ESCALATIONS}->{$hostesc}->{$val}\n";
				}
				print FH "}\n";
				print FH "\n";
			}	
		}
		
		# generate hostescalations
		foreach my $service(keys %{$CLIENTS->{$client}->{SERVICES}}) {
			# only if service is not disabled
			if (!$CLIENTS->{$client}->{SERVICES}->{$service}->{"$cfg->{ldap}->{prefix}servicedisable"}) {
				foreach my $serviceesc (keys %{$CLIENTS->{$client}->{SERVICES}->{$service}->{ESCALATIONS}}) {
					print FH "define serviceescalation {\n";
					print FH "\thost_name\t$CLIENTS->{$client}->{cn}\n";
					print FH "\tservice_description\t$service\n";
					foreach my $val (keys %{$CLIENTS->{$client}->{SERVICES}->{$service}->{ESCALATIONS}->{$serviceesc}}) {
						print FH "\t$itemMap{$val}\t$CLIENTS->{$client}->{SERVICES}->{$service}->{ESCALATIONS}->{$serviceesc}->{$val}\n";
					}
					print FH "}\n";
					print FH "\n";
				}
			}
		}

		# close target file
		close(FH);
		}
		}
	}
}

1;